{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,kFAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,oEAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,MAAM;AACN;AACA;AACA;AACA,KAAK,6BAA6B;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACnSA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;ACVP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,IAAI,GAAG,IAAI,SAAS,IAAI;AAC/I;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC/DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrB8B;AACnB;AACqD;AAChE,iBAAiB,8CAAM;AAC6B;AACR;AACD;AACJ;AACD;AACS;AACY;AAChB;AACmB;AACT;AACM;;;;;;;;;;;;;;;;;;;;;;;;;ACdO;AACX;AAChB;AACA;AACS;AACX;AACsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,mCAAmC,iEAAO;AACjD;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,0BAA0B,+DAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAK;AACjC;AACA,QAAQ,+DAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,2DAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA,sCAAsC;AACtC;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wBAAwB,6BAA6B;AACrD;AACA;AACA,+BAA+B,oDAAU;AACzC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,wCAAwC,4DAAkB;AAC1D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACttBgD;AACO;AACL;AACJ;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,iEAAO;AACtC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,uBAAuB,8DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAM;AACnC;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7I4C;AACH;AACF;AAChC;AACP,eAAe,kDAAE;AACjB,kBAAkB,gDAAE;AACpB,aAAa,qDAAG;AAChB;;;;;;;;;;;;;;;;;ACPuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,gDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvDuC;AACgB;AACE;AACS;AACjB;AACjD;AACO,sBAAsB,gDAAO;AACpC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO,sBAAsB,iEAAO;AACpC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4DAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,yDAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAU;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9Q4C;AACF;AACsB;AACzD,sBAAsB,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,+DAAa;AACrB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChJ4C;AACI;AACA;AAC4B;AAC5E;AACA;AACA;AACA;AACO,qBAAqB,oDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,YAAY,8DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAQ;AAC5B;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,cAAc,4DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5H4C;AACE;AAC2C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,oDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,2EAAyB;AAC/D;AACA,sCAAsC,2EAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iCAAiC;AACjC;AACA,oCAAoC,SAAS,eAAe,EAAE;AAC9D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,0DAAQ;AAC5B;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/EiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA,2BAA2B,4DAAU;AACrC,6BAA6B,4DAAU;AAChC;AACP;AACA,mDAAmD,4DAAU;AAC7D,uDAAuD,4DAAU;AACjE;AACA;AACA,2BAA2B,4DAAU,iBAAiB,4DAAU;AAChE,6BAA6B,4DAAU,mBAAmB,4DAAU;AACpE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;AACqC;;;;;;;;;;;;;;;;;ACb5D;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACO;AACP;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1CmE;AACV;AACzD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAoB;AAC3C;AACA,eAAe,qDAAY;AAC3B;AACA;AACA;AACA,kBAAkB,6DAAoB;AACtC;AACA;AACA;AACA,kBAAkB,6DAAoB;AACtC;AACA;AACA;AACA;AACA,wBAAwB,sEAAM;AAC9B;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7D4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACwB;;;;;;;;;;;;;;;;;;;;;;;;;ACnE+C;AACtB;AACJ;AAC7C,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAY;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,8BAA8B,8DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,sEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qDAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAY;AACnD;AACA;AACA;AACA,uCAAuC,qDAAY;AACnD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AAC8D;;;;;;;;;;;;;;;;AC3JrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjE+B;AACQ;AACF;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA,4BAA4B,gDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AAC4C;AAC5C;AACA;AACA;AACA;AACA;AACgF;AACgB;;;;;;;;;;;;;;;;;;;;;;ACzDV;AACjD;AACM;AACd;AACiB;AACU;AACjD,sBAAsB,iEAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAO;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,6CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAM;AAChC;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAE;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAAE,0CAA0C,0CAAE,0CAA0C,0CAAE,4CAA4C,0CAAE;AAC/J;AACA,QAAQ,0CAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAQ;AAChB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9WO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACL8C;AACjB;AAC2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C,IAAI;AACJ;AACO,qBAAqB,iEAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,YAAY;AACZ;AACA;AACA,4CAA4C;AAC5C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA,+CAA+C,KAAK,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,QAAQ;AACR;AACA;AACA,2CAA2C;AAC3C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAE;AACd,YAAY,0CAAE;AACd,YAAY,0CAAE;AACd,YAAY,0CAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,qCAAqC;AACrC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA,kCAAkC,0CAA0C;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAU;AAC3B,iBAAiB,wDAAU;AAC3B;AACA;AACA,iBAAiB,wDAAU;AAC3B,iBAAiB,wDAAU;AAC3B;AACA;AACA,iBAAiB,wDAAU;AAC3B;AACA;AACA,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,wDAAU,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/2ByC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1D0C;AAC1C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uCAAuC;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,uDAAQ;AAChB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClFuD;AACY;AACd;AACrB,CAAC;AACjC,cAAc,kCAAW,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,gBAAgB,wDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAiB;AAChD;AACA;AACA,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACO,sBAAsB,iEAAO;AACpC;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3CqC;AACI;AACa;AACK;AAClB;AACW;;AAE7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAM;AAChC,4BAA4B,kDAAQ;AACpC,yBAAyB,2DAAS;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,4DAAM;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4DAAM;AACtB;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,YAAY,4DAAM;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD,wBAAwB,WAAW;AACnC,oCAAoC,kDAAQ;AAC5C;AACA;AACA;;;;;;;;;;;;;;;;ACpNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvB0E;AAC1B;;AAEzC;AACP;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA,oCAAoC;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM,GAAG,EAAE;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,EAAE,IAAI,EAAE,IAAI,EAAE;AACvD,2CAA2C,EAAE,IAAI,EAAE,IAAI,EAAE;AACzD;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,gEAAa;AACzC,yBAAyB,gEAAa;AACtC,yBAAyB,gEAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D,UAAU;AACV;AACA;AACA,mCAAmC,8BAA8B,IAAI,8BAA8B,IAAI,8BAA8B;;AAErI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AACzE;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E,UAAU;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uBAAuB;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,YAAY;AACvE;;AAEA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA,cAAc;AACd;AACA;AACA;AACA,4DAA4D,6BAA6B;AACzF;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,gEAAa,gBAAgB,gEAAa;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAM;AACrE;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,gEAAa,gBAAgB,gEAAa;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gEAAa,YAAY,gEAAa;;AAE5D;AACA;AACA;AACA;AACA,6BAA6B,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAM;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,+CAA+C;AACvG;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;AC/kBsC;AACU;AACJ;AACU;AACF;;AAE7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,oDAAE;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,kCAAkC,2DAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,iDAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,wCAAwC,qDAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,WAAW;AAC3D,qDAAqD,cAAc;AACnE,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,4DAAM;AACtB,cAAc;AACd,gBAAgB,4DAAM;AACtB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yDAAyD,kBAAkB,gBAAgB;;AAE3F;;AAEA;AACA,qDAAqD,oBAAoB,cAAc,0BAA0B,IAAI,qCAAqC;;AAE1J;AACA;AACA;AACA,6EAA6E,MAAM;AACnF;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C,SAAS,eAAe,eAAe,oCAAoC,oBAAoB,yBAAyB,QAAQ;AAC7K,uDAAuD,gCAAgC,qBAAqB,mBAAmB;AAC/H,+DAA+D,IAAI,MAAM;AACzE,8DAA8D,aAAa,cAAc,SAAS;AAClG;AACA,uDAAuD,gCAAgC,UAAU,iBAAiB,aAAa;AAC/H,oDAAoD,SAAS;AAC7D,kDAAkD,WAAW;AAC7D,kDAAkD,UAAU;AAC5D,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,+CAA+C,yBAAyB,WAAW,oBAAoB;AACvG,yIAAyI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AACrO,qIAAqI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AACjO,qIAAqI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AACjO;AACA,mDAAmD;AACnD,0DAA0D,WAAW,YAAY,YAAY,iCAAiC,6BAA6B,mBAAmB;AAC9K,4FAA4F,UAAU,YAAY,6BAA6B,cAAc,cAAc,oBAAoB,iBAAiB,kBAAkB,gBAAgB;AAClP;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,QAAQ,SAAS,UAAU;AAC5D,8CAA8C;AAC9C,yCAAyC,qBAAqB;AAC9D;;AAEA;AACA;AACA,oCAAoC;AACpC,oCAAoC,QAAQ;AAC5C,oCAAoC;AACpC;;AAEA;AACA,4EAA4E,2BAA2B;AACvG,wCAAwC,WAAW;AACnD,sCAAsC,cAAc;AACpD,qCAAqC,iBAAiB;AACtD,yBAAyB;AACzB,oCAAoC,QAAQ,iBAAiB,oBAAoB,oBAAoB,IAAI,IAAI;AAC7G,kBAAkB;AAClB,kBAAkB;AAClB,uCAAuC,oBAAoB,IAAI,wDAAwD;AACvH;AACA,kCAAkC,QAAQ,cAAc;AACxD,wCAAwC,iBAAiB;AACzD,wCAAwC;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,qEAAqE,EAAE;AACvE;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,mCAAmC;AACnC,kBAAkB;AAClB;AACA;AACA,oCAAoC;AACpC,kBAAkB;AAClB;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+DAA+D;;AAE/D;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAI;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4DAAM;AACtB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,qDAAM;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnhB4D;AAChB;AACI;AACY;AACR;;AAE7C;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA,8BAA8B,iEAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,iEAAY;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,oCAAoC,qDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,4DAAM;AAClB,UAAU;AACV,YAAY,4DAAM;AAClB;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,kBAAkB,iBAAiB,mBAAmB,iBAAiB;;AAE5H;;AAEA;AACA,iDAAiD,oBAAoB,cAAc,0BAA0B,IAAI,qCAAqC;;AAEtJ;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS,eAAe,eAAe,oCAAoC,oBAAoB,yBAAyB,QAAQ;AACzK,mDAAmD,gCAAgC,qBAAqB,mBAAmB;AAC3H,2DAA2D,IAAI,MAAM;AACrE,0DAA0D,aAAa,cAAc,SAAS;AAC9F;AACA,mDAAmD,gCAAgC,UAAU,iBAAiB,aAAa;AAC3H,gDAAgD,SAAS;AACzD,8CAA8C,WAAW;AACzD,8CAA8C,UAAU;AACxD,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,2CAA2C,yBAAyB,WAAW,oBAAoB;AACnG,qIAAqI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AACjO,iIAAiI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AAC7N,iIAAiI,wBAAwB,aAAa,mBAAmB,iBAAiB,mBAAmB;AAC7N;AACA,+CAA+C;AAC/C,yDAAyD,WAAW,YAAY,YAAY,iCAAiC,6BAA6B,mBAAmB;AAC7K,wFAAwF,UAAU,YAAY,6BAA6B,cAAc,cAAc,oBAAoB,iBAAiB,kBAAkB,gBAAgB;AAC9O;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,QAAQ,SAAS,aAAa;AAC3D,yCAAyC;AACzC,2BAA2B;AAC3B,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,gCAAgC,QAAQ;AACxC,gCAAgC;AAChC,8BAA8B;AAC9B,mCAAmC,MAAM;AACzC;;AAEA;AACA,gCAAgC,QAAQ,iBAAiB,oBAAoB,qBAAqB,wBAAwB,MAAM,GAAG,IAAI,IAAI;AAC3I,mCAAmC,iBAAiB,oBAAoB,IAAI,uDAAuD;AACnI;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA,kCAAkC;AAClC,8BAA8B,QAAQ,cAAc;AACpD,8BAA8B;AAC9B,iCAAiC,iBAAiB;AAClD,sCAAsC,uBAAuB,MAAM,GAAG;AACtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,+BAA+B;AAC/B,cAAc;AACd;AACA;AACA,gCAAgC;AAChC,cAAc;AACd;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kCAAkC;AAC3E,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACxU2C;;AAEpC;AACP;AACA;AACA;AACA,uBAAuB;AACvB,8BAA8B;AAC9B;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;ACvH2C;;AAEpC;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB,oDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,oDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAM;AAClB,UAAU;AACV,YAAY,oDAAM;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3TA;AACA;;AAEO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACO;;;;;;;;;;;;;;;;AC1OA;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,gBAAgB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,GAAG,oCAAoC;;AAE/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,eAAe;;;AAGtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,6CAA6C;;AAE7C;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C;AAC1C,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,MAAM;;AAElD;AACA;AACA,4BAA4B,MAAM,IAAI,WAAW,OAAO,UAAU,GAAG,QAAQ;;AAE7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnHO;AACP;AACA;AACA;AACA,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAM;AAC3C;;AAEO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,UAAU,0BAA0B,gBAAgB,gBAAgB,iBAAiB;AAC7H;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE;;AAErE;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,SAAS;;AAET;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;AC1J+D;;AAExD;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,MAAM;AACpC;;AAEA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE,UAAU;AACV,yEAAyE;AACzE;;AAEA,2EAA2E;AAC3E,oDAAoD;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,yDAAa;AACzC,yBAAyB,yDAAa;AACtC,yBAAyB,yDAAa;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,yDAAa,cAAc,yDAAa;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtZO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP,aAAa,kEAAkE;AAC/E,cAAc,oEAAoE;AAClF,aAAa;AACb;;;;;;;;;;;;;;;;;;;AChByD;AACT;AACD;;AAExC;AACP;AACA;AACA;AACA;AACA,oCAAoC,kEAAgB;AACpD,0BAA0B,yDAAa;AACvC,2BAA2B,yDAAa;AACxC,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,wDAAW,yCAAyC;AACnF,oCAAoC,wDAAW,0CAA0C;AACzF,0CAA0C;AAC1C,8BAA8B;AAC9B,qCAAqC;;AAErC;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,qEAAqE;AACrE;AACA;AACA,wBAAwB;AACxB,oBAAoB;AACpB,uBAAuB;AACvB,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ,GAAG,eAAe;AACvE,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBiC;;AAE1B;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,iDAAiD;AAC/D,cAAc,mCAAmC;AACjD,cAAc,qCAAqC;AACnD;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,2BAA2B,0CAAI;AAC/B;;AAEA;AACA,uBAAuB,0CAAI;;AAE3B;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA,kCAAkC,eAAe;AACjD;AACA;AACA;;AAEA;AACA,yCAAyC,oBAAoB;AAC7D,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,0CAAI,sCAAsC;AACrE,2BAA2B,0CAAI,mDAAmD;AAClF,2BAA2B,0CAAI,oDAAoD;AACnF,2BAA2B,0CAAI,iEAAiE;AAChG,SAAS;;AAET;AACA;AACA;;;;;;;;;;;;;;;;;;ACjFgD;AACX,CAAC;AACtC;;AAEO;AACP;AACA,sBAAsB,YAAY,YAAY,sBAAsB;;AAEpE;AACA;AACA;AACA,6BAA6B;AAC7B,sCAAsC;AACtC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,sCAAsC;AACtC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,0BAA0B,mBAAmB,uBAAuB,kCAAkC,wBAAwB;AAChK,iCAAiC;AACjC;;AAEA,iBAAiB,uCAAuC,yDAAa,cAAc,yDAAa;;AAEhG;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA,8BAA8B,yDAAa,cAAc,yDAAa;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,0DAA0D,yDAAa,cAAc,yDAAa;AAClG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA,qEAAqE;AACrE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;AACA,mCAAmC,8CAAM;;AAEzC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpOO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UClHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WC5BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;ACNsC;AACmB;AACQ;AACd;AACwB;AACF;AACtB;AACA;;AAEnD;AACA,qBAAqB,+CAAI;;AAEzB;AACA;AACA,uBAAuB,0EAAgB;AACvC,gBAAgB,4DAAS;AACzB;AACA,6BAA6B,kEAAY;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oFAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,8BAA8B,kFAAqB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,4DAAM;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://nanowar-multiplayer/./node_modules/socket.io-parser/node_modules/debug/src/browser.js","webpack://nanowar-multiplayer/./node_modules/socket.io-parser/node_modules/debug/src/common.js","webpack://nanowar-multiplayer/./node_modules/socket.io-parser/node_modules/ms/index.js","webpack://nanowar-multiplayer/./node_modules/@socket.io/component-emitter/lib/esm/index.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/contrib/has-cors.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/contrib/parseqs.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/contrib/parseuri.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/globals.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/index.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/socket.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transport.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/index.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/polling-fetch.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/polling-xhr.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/polling.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/websocket.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/transports/webtransport.js","webpack://nanowar-multiplayer/./node_modules/engine.io-client/build/esm/util.js","webpack://nanowar-multiplayer/./node_modules/engine.io-parser/build/esm/commons.js","webpack://nanowar-multiplayer/./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js","webpack://nanowar-multiplayer/./node_modules/engine.io-parser/build/esm/decodePacket.browser.js","webpack://nanowar-multiplayer/./node_modules/engine.io-parser/build/esm/encodePacket.browser.js","webpack://nanowar-multiplayer/./node_modules/engine.io-parser/build/esm/index.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/contrib/backo2.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/index.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/manager.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/on.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/socket.js","webpack://nanowar-multiplayer/./node_modules/socket.io-client/build/esm/url.js","webpack://nanowar-multiplayer/./node_modules/socket.io-parser/build/esm-debug/binary.js","webpack://nanowar-multiplayer/./node_modules/socket.io-parser/build/esm-debug/index.js","webpack://nanowar-multiplayer/./node_modules/socket.io-parser/build/esm-debug/is-binary.js","webpack://nanowar-multiplayer/./src/client/core/Camera.js","webpack://nanowar-multiplayer/./src/client/core/Game.js","webpack://nanowar-multiplayer/./src/client/core/Particle.js","webpack://nanowar-multiplayer/./src/client/core/Renderer.js","webpack://nanowar-multiplayer/./src/client/modes/MultiplayerController.js","webpack://nanowar-multiplayer/./src/client/modes/SingleplayerController.js","webpack://nanowar-multiplayer/./src/client/systems/InputManager.js","webpack://nanowar-multiplayer/./src/client/systems/SelectionManager.js","webpack://nanowar-multiplayer/./src/client/systems/SoundManager.js","webpack://nanowar-multiplayer/./src/client/systems/UIManager.js","webpack://nanowar-multiplayer/./src/client/utils/helpers.js","webpack://nanowar-multiplayer/./src/shared/AIController.js","webpack://nanowar-multiplayer/./src/shared/Entity.js","webpack://nanowar-multiplayer/./src/shared/GameConfig.js","webpack://nanowar-multiplayer/./src/shared/GameState.js","webpack://nanowar-multiplayer/./src/shared/GlobalSpawnTimer.js","webpack://nanowar-multiplayer/./src/shared/MapGenerator.js","webpack://nanowar-multiplayer/./src/shared/Node.js","webpack://nanowar-multiplayer/./src/shared/SpatialGrid.js","webpack://nanowar-multiplayer/webpack/bootstrap","webpack://nanowar-multiplayer/webpack/runtime/define property getters","webpack://nanowar-multiplayer/webpack/runtime/hasOwnProperty shorthand","webpack://nanowar-multiplayer/webpack/runtime/make namespace object","webpack://nanowar-multiplayer/./src/client/main.js"],"sourcesContent":["/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nexport function Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n","// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nexport const hasCORS = value;\n","// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nexport function encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nexport function decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n","// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nexport function parse(str) {\n    if (str.length > 8000) {\n        throw \"URI too long\";\n    }\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n","export const nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexport const globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\nexport const defaultBinaryType = \"arraybuffer\";\nexport function createCookieJar() { }\n","import { Socket } from \"./socket.js\";\nexport { Socket };\nexport { SocketWithoutUpgrade, SocketWithUpgrade, } from \"./socket.js\";\nexport const protocol = Socket.protocol;\nexport { Transport, TransportError } from \"./transport.js\";\nexport { transports } from \"./transports/index.js\";\nexport { installTimerFunctions } from \"./util.js\";\nexport { parse } from \"./contrib/parseuri.js\";\nexport { nextTick } from \"./globals.node.js\";\nexport { Fetch } from \"./transports/polling-fetch.js\";\nexport { XHR as NodeXHR } from \"./transports/polling-xhr.node.js\";\nexport { XHR } from \"./transports/polling-xhr.js\";\nexport { WS as NodeWebSocket } from \"./transports/websocket.node.js\";\nexport { WS as WebSocket } from \"./transports/websocket.js\";\nexport { WT as WebTransport } from \"./transports/webtransport.js\";\n","import { transports as DEFAULT_TRANSPORTS } from \"./transports/index.js\";\nimport { installTimerFunctions, byteLength } from \"./util.js\";\nimport { decode } from \"./contrib/parseqs.js\";\nimport { parse } from \"./contrib/parseuri.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nimport { createCookieJar, defaultBinaryType, nextTick, } from \"./globals.node.js\";\nconst withEventListeners = typeof addEventListener === \"function\" &&\n    typeof removeEventListener === \"function\";\nconst OFFLINE_EVENT_LISTENERS = [];\nif (withEventListeners) {\n    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the\n    // script, so we create one single event listener here which will forward the event to the socket instances\n    addEventListener(\"offline\", () => {\n        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());\n    }, false);\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that\n * successfully establishes the connection.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithoutUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithoutUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithUpgrade\n * @see Socket\n */\nexport class SocketWithoutUpgrade extends Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts) {\n        super();\n        this.binaryType = defaultBinaryType;\n        this.writeBuffer = [];\n        this._prevBufferLen = 0;\n        this._pingInterval = -1;\n        this._pingTimeout = -1;\n        this._maxPayload = -1;\n        /**\n         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the\n         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.\n         */\n        this._pingTimeoutTime = Infinity;\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            const parsedUri = parse(uri);\n            opts.hostname = parsedUri.host;\n            opts.secure =\n                parsedUri.protocol === \"https\" || parsedUri.protocol === \"wss\";\n            opts.port = parsedUri.port;\n            if (parsedUri.query)\n                opts.query = parsedUri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parse(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = [];\n        this._transportsByName = {};\n        opts.transports.forEach((t) => {\n            const transportName = t.prototype.name;\n            this.transports.push(transportName);\n            this._transportsByName[transportName] = t;\n        });\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = decode(this.opts.query);\n        }\n        if (withEventListeners) {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this._beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this._offlineEventListener = () => {\n                    this._onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);\n            }\n        }\n        if (this.opts.withCredentials) {\n            this._cookieJar = createCookieJar();\n        }\n        this._open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new this._transportsByName[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    _open() {\n        if (this.transports.length === 0) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        const transportName = this.opts.rememberUpgrade &&\n            SocketWithoutUpgrade.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1\n            ? \"websocket\"\n            : this.transports[0];\n        this.readyState = \"opening\";\n        const transport = this.createTransport(transportName);\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this._onDrain.bind(this))\n            .on(\"packet\", this._onPacket.bind(this))\n            .on(\"error\", this._onError.bind(this))\n            .on(\"close\", (reason) => this._onClose(\"transport close\", reason));\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        SocketWithoutUpgrade.priorWebsocketSuccess =\n            \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    _onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this._sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    this._resetPingTimeout();\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this._onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this._pingInterval = data.pingInterval;\n        this._pingTimeout = data.pingTimeout;\n        this._maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this._resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    _resetPingTimeout() {\n        this.clearTimeoutFn(this._pingTimeoutTimer);\n        const delay = this._pingInterval + this._pingTimeout;\n        this._pingTimeoutTime = Date.now() + delay;\n        this._pingTimeoutTimer = this.setTimeoutFn(() => {\n            this._onClose(\"ping timeout\");\n        }, delay);\n        if (this.opts.autoUnref) {\n            this._pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    _onDrain() {\n        this.writeBuffer.splice(0, this._prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this._prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this._getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this._prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    _getWritablePackets() {\n        const shouldCheckPayloadSize = this._maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += byteLength(data);\n            }\n            if (i > 0 && payloadSize > this._maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.\n     *\n     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the\n     * `write()` method then the message would not be buffered by the Socket.IO client.\n     *\n     * @return {boolean}\n     * @private\n     */\n    /* private */ _hasPingExpired() {\n        if (!this._pingTimeoutTime)\n            return true;\n        const hasExpired = Date.now() > this._pingTimeoutTime;\n        if (hasExpired) {\n            this._pingTimeoutTime = 0;\n            nextTick(() => {\n                this._onClose(\"ping timeout\");\n            }, this.setTimeoutFn);\n        }\n        return hasExpired;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a message. Alias of {@link Socket#write}.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    send(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    _sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this._onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    _onError(err) {\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        if (this.opts.tryAllTransports &&\n            this.transports.length > 1 &&\n            this.readyState === \"opening\") {\n            this.transports.shift();\n            return this._open();\n        }\n        this.emitReserved(\"error\", err);\n        this._onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    _onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this._pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (withEventListeners) {\n                if (this._beforeunloadEventListener) {\n                    removeEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n                }\n                if (this._offlineEventListener) {\n                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);\n                    if (i !== -1) {\n                        OFFLINE_EVENT_LISTENERS.splice(i, 1);\n                    }\n                }\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this._prevBufferLen = 0;\n        }\n    }\n}\nSocketWithoutUpgrade.protocol = protocol;\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see Socket\n */\nexport class SocketWithUpgrade extends SocketWithoutUpgrade {\n    constructor() {\n        super(...arguments);\n        this._upgrades = [];\n    }\n    onOpen() {\n        super.onOpen();\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            for (let i = 0; i < this._upgrades.length; i++) {\n                this._probe(this._upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    _probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    SocketWithoutUpgrade.priorWebsocketSuccess =\n                        \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this._upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    onHandshake(data) {\n        this._upgrades = this._filterUpgrades(data.upgrades);\n        super.onHandshake(data);\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    _filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        for (let i = 0; i < upgrades.length; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * @example\n * import { Socket } from \"engine.io-client\";\n *\n * const socket = new Socket();\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see SocketWithUpgrade\n */\nexport class Socket extends SocketWithUpgrade {\n    constructor(uri, opts = {}) {\n        const o = typeof uri === \"object\" ? uri : opts;\n        if (!o.transports ||\n            (o.transports && typeof o.transports[0] === \"string\")) {\n            o.transports = (o.transports || [\"polling\", \"websocket\", \"webtransport\"])\n                .map((transportName) => DEFAULT_TRANSPORTS[transportName])\n                .filter((t) => !!t);\n        }\n        super(uri, o);\n    }\n}\n","import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nimport { encode } from \"./contrib/parseqs.js\";\nexport class TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nexport class Transport extends Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port) !== 443) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = encode(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n","import { XHR } from \"./polling-xhr.node.js\";\nimport { WS } from \"./websocket.node.js\";\nimport { WT } from \"./webtransport.js\";\nexport const transports = {\n    websocket: WS,\n    webtransport: WT,\n    polling: XHR,\n};\n","import { Polling } from \"./polling.js\";\n/**\n * HTTP long-polling based on the built-in `fetch()` method.\n *\n * Usage: browser, Node.js (since v18), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch\n * @see https://caniuse.com/fetch\n * @see https://nodejs.org/api/globals.html#fetch\n */\nexport class Fetch extends Polling {\n    doPoll() {\n        this._fetch()\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch read error\", res.status, res);\n            }\n            res.text().then((data) => this.onData(data));\n        })\n            .catch((err) => {\n            this.onError(\"fetch read error\", err);\n        });\n    }\n    doWrite(data, callback) {\n        this._fetch(data)\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch write error\", res.status, res);\n            }\n            callback();\n        })\n            .catch((err) => {\n            this.onError(\"fetch write error\", err);\n        });\n    }\n    _fetch(data) {\n        var _a;\n        const isPost = data !== undefined;\n        const headers = new Headers(this.opts.extraHeaders);\n        if (isPost) {\n            headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n        }\n        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);\n        return fetch(this.uri(), {\n            method: isPost ? \"POST\" : \"GET\",\n            body: isPost ? data : null,\n            headers,\n            credentials: this.opts.withCredentials ? \"include\" : \"omit\",\n        }).then((res) => {\n            var _a;\n            // @ts-ignore getSetCookie() was added in Node.js v19.7.0\n            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());\n            return res;\n        });\n    }\n}\n","import { Polling } from \"./polling.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { globalThisShim as globalThis } from \"../globals.node.js\";\nimport { hasCORS } from \"../contrib/has-cors.js\";\nfunction empty() { }\nexport class BaseXHR extends Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nexport class Request extends Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(createRequest, uri, opts) {\n        super();\n        this.createRequest = createRequest;\n        installTimerFunctions(this, opts);\n        this._opts = opts;\n        this._method = opts.method || \"GET\";\n        this._uri = uri;\n        this._data = undefined !== opts.data ? opts.data : null;\n        this._create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    _create() {\n        var _a;\n        const opts = pick(this._opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this._opts.xd;\n        const xhr = (this._xhr = this.createRequest(opts));\n        try {\n            xhr.open(this._method, this._uri, true);\n            try {\n                if (this._opts.extraHeaders) {\n                    // @ts-ignore\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this._opts.extraHeaders) {\n                        if (this._opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this._method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this._opts.withCredentials;\n            }\n            if (this._opts.requestTimeout) {\n                xhr.timeout = this._opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(\n                    // @ts-ignore\n                    xhr.getResponseHeader(\"set-cookie\"));\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this._onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this._onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this._data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this._onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this._index = Request.requestsCount++;\n            Request.requests[this._index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    _onError(err) {\n        this.emitReserved(\"error\", err, this._xhr);\n        this._cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    _cleanup(fromError) {\n        if (\"undefined\" === typeof this._xhr || null === this._xhr) {\n            return;\n        }\n        this._xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this._xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this._index];\n        }\n        this._xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    _onLoad() {\n        const data = this._xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this._cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this._cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\nconst hasXHR2 = (function () {\n    const xhr = newRequest({\n        xdomain: false,\n    });\n    return xhr && xhr.responseType !== null;\n})();\n/**\n * HTTP long-polling based on the built-in `XMLHttpRequest` object.\n *\n * Usage: browser\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nexport class XHR extends BaseXHR {\n    constructor(opts) {\n        super(opts);\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd }, this.opts);\n        return new Request(newRequest, this.uri(), opts);\n    }\n}\nfunction newRequest(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { randomString } from \"../util.js\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport class Polling extends Transport {\n    constructor() {\n        super(...arguments);\n        this._polling = false;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this._poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this._polling || !this.writable) {\n            let total = 0;\n            if (this._polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    _poll() {\n        this._polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this._polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this._poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { pick, randomString } from \"../util.js\";\nimport { encodePacket } from \"engine.io-parser\";\nimport { globalThisShim as globalThis, nextTick } from \"../globals.node.js\";\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nexport class BaseWS extends Transport {\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws = this.createSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, (data) => {\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    this.doWrite(packet, data);\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.onerror = () => { };\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\nconst WebSocketCtor = globalThis.WebSocket || globalThis.MozWebSocket;\n/**\n * WebSocket transport based on the built-in `WebSocket` object.\n *\n * Usage: browser, Node.js (since v21), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n * @see https://nodejs.org/api/globals.html#websocket\n */\nexport class WS extends BaseWS {\n    createSocket(uri, protocols, opts) {\n        return !isReactNative\n            ? protocols\n                ? new WebSocketCtor(uri, protocols)\n                : new WebSocketCtor(uri)\n            : new WebSocketCtor(uri, protocols, opts);\n    }\n    doWrite(_packet, data) {\n        this.ws.send(data);\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { nextTick } from \"../globals.node.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream, } from \"engine.io-parser\";\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        try {\n            // @ts-ignore\n            this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this._transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this._transport.ready.then(() => {\n            this._transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = createPacketEncoderStream();\n                encoderStream.readable.pipeTo(stream.writable);\n                this._writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this._writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this._writer.write(packet).then(() => {\n                if (lastPacket) {\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n","import { globalThisShim as globalThis } from \"./globals.node.js\";\nexport function pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = globalThis.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = globalThis.clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = globalThis.setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = globalThis.clearTimeout.bind(globalThis);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nexport function byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n/**\n * Generates a random 8-characters string.\n */\nexport function randomString() {\n    return (Date.now().toString(36).substring(3) +\n        Math.random().toString(36).substring(2, 5));\n}\n","const PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach((key) => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexport { PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET };\n","// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nexport const encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexport const decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n","import { ERROR_PACKET, PACKET_TYPES_REVERSE, } from \"./commons.js\";\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nexport const decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType),\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),\n        };\n    }\n    const packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1),\n        }\n        : {\n            type: PACKET_TYPES_REVERSE[type],\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = decode(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n","import { PACKET_TYPES } from \"./commons.js\";\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nexport function encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data.arrayBuffer().then(toArray).then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, (encoded) => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\nexport { encodePacket };\n","import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET, } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, (encodedPacket) => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexport function createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            encodePacketToBinary(packet, (encodedPacket) => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        },\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* State.READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* State.READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* State.READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* State.READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(ERROR_PACKET);\n                    break;\n                }\n            }\n        },\n    });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload, };\n","/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nexport function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\nexport { Fetch, NodeXHR, XHR, NodeWebSocket, WebSocket, WebTransport, } from \"engine.io-client\";\n","import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        if (!v) {\n            this.skipReconnect = true;\n        }\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), \n        // @ts-ignore\n        on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called when:\n     *\n     * - the low-level engine is closed\n     * - the parser encountered a badly formatted packet\n     * - all sockets are disconnected\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        var _a;\n        this.cleanup();\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n","export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        var _a, _b, _c;\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;\n        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());\n        const discardPacket = this.flags.volatile && !isTransportWritable;\n        if (discardPacket) {\n        }\n        else if (isConnected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this._drainQueue(true);\n        this.emitReserved(\"connect\");\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n","import { parse } from \"engine.io-client\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n","import { isBinary } from \"./is-binary.js\";\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nexport function deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nexport function reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","import { Emitter } from \"@socket.io/component-emitter\";\nimport { deconstructPacket, reconstructPacket } from \"./binary.js\";\nimport { isBinary, hasBinary } from \"./is-binary.js\";\nimport debugModule from \"debug\"; // debug()\nconst debug = debugModule(\"socket.io-parser\"); // debug()\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\", // used on the client side\n    \"connect_error\", // used on the client side\n    \"disconnect\", // used on both sides\n    \"disconnecting\", // used on the server side\n    \"newListener\", // used by the Node.js EventEmitter\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nexport const protocol = 5;\nexport var PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nexport class Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (hasBinary(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nexport class Decoder extends Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\nfunction isNamespaceValid(nsp) {\n    return typeof nsp === \"string\";\n}\n// see https://caniuse.com/mdn-javascript_builtins_number_isinteger\nconst isInteger = Number.isInteger ||\n    function (value) {\n        return (typeof value === \"number\" &&\n            isFinite(value) &&\n            Math.floor(value) === value);\n    };\nfunction isAckIdValid(id) {\n    return id === undefined || isInteger(id);\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\nfunction isDataValid(type, payload) {\n    switch (type) {\n        case PacketType.CONNECT:\n            return payload === undefined || isObject(payload);\n        case PacketType.DISCONNECT:\n            return payload === undefined;\n        case PacketType.EVENT:\n            return (Array.isArray(payload) &&\n                (typeof payload[0] === \"number\" ||\n                    (typeof payload[0] === \"string\" &&\n                        RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n        case PacketType.ACK:\n            return Array.isArray(payload);\n        case PacketType.CONNECT_ERROR:\n            return typeof payload === \"string\" || isObject(payload);\n        default:\n            return false;\n    }\n}\nexport function isPacketValid(packet) {\n    return (isNamespaceValid(packet.nsp) &&\n        isAckIdValid(packet.id) &&\n        isDataValid(packet.type, packet.data));\n}\n","const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nexport function isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexport function hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n","export class Camera {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.zoom = 1;\n        this.minZoom = 0.1;\n        this.maxZoom = 3;\n    }\n    worldToScreen(worldX, worldY) {\n        return {\n            x: (worldX - this.x) * this.zoom,\n            y: (worldY - this.y) * this.zoom\n        };\n    }\n    screenToWorld(screenX, screenY) {\n        return {\n            x: screenX / this.zoom + this.x,\n            y: screenY / this.zoom + this.y\n        };\n    }\n    zoomAt(screenX, screenY, delta) {\n        const worldPos = this.screenToWorld(screenX, screenY);\n        this.zoom *= delta;\n        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));\n        this.x = worldPos.x - screenX / this.zoom;\n        this.y = worldPos.y - screenY / this.zoom;\n    }\n    pan(dx, dy) {\n        this.x -= dx / this.zoom;\n        this.y -= dy / this.zoom;\n    }\n    zoomToFit(worldWidth, worldHeight, screenWidth, screenHeight) {\n        const padding = 100;\n        const zoomX = screenWidth / (worldWidth + padding * 2);\n        const zoomY = screenHeight / (worldHeight + padding * 2);\n        this.zoom = Math.min(zoomX, zoomY);\n        this.x = -padding;\n        this.y = -padding;\n    }\n    centerOn(worldX, worldY, screenWidth, screenHeight) {\n        this.x = worldX - screenWidth / (2 * this.zoom);\n        this.y = worldY - screenHeight / (2 * this.zoom);\n    }\n}\n","import { Camera } from './Camera.js';\nimport { Renderer } from './Renderer.js';\nimport { GameState } from '../../shared/GameState.js';\nimport { GAME_SETTINGS } from '../../shared/GameConfig.js';\nimport { Particle } from './Particle.js';\nimport { sounds } from '../systems/SoundManager.js';\n\nexport class Game {\n    constructor(canvasId) {\n        this.canvas = document.getElementById(canvasId);\n        if (!this.canvas) {\n            console.error('Canvas not found:', canvasId);\n            return;\n        }\n        this.ctx = this.canvas.getContext('2d');\n        this.camera = new Camera();\n        this.renderer = new Renderer(this.ctx, this);\n        this.state = new GameState();\n        this.particles = [];\n        this.commandIndicators = [];\n        this.waypointLines = [];\n\n        this.running = false;\n        this.gameOverShown = false;\n        this.healSoundCooldown = 0;\n        this.healSoundDelay = 5; // Don't play heal sounds first 5 seconds\n        this.resize();\n        window.addEventListener('resize', () => this.resize());\n\n        this.camera.zoomToFit(this.state.worldWidth, this.state.worldHeight, this.canvas.width, this.canvas.height);\n    }\n\n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        if (this.renderer && this.renderer.resize) {\n            this.renderer.resize(window.innerWidth, window.innerHeight);\n        }\n    }\n\n    start() {\n        if (this.running) return;\n        this.running = true;\n        this.lastTime = performance.now();\n        this.healSoundCooldown = 0;\n        this.healSoundDelay = 5; // 5 second delay before heal sounds\n\n        const game = this;\n        const loop = (now) => {\n            if (!game.running) return;\n            const dt = Math.min((now - game.lastTime) / 1000, 0.05);\n            game.lastTime = now;\n\n            game.update(dt);\n            game.draw(dt);\n\n            game.animationId = requestAnimationFrame(loop);\n        };\n        game.animationId = requestAnimationFrame(loop);\n    }\n\n    stop() {\n        this.running = false;\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n            this.animationId = null;\n        }\n    }\n\n    update(dt) {\n        // Set player index for sounds\n        sounds.setPlayerIndex(this.controller?.playerIndex ?? 0);\n\n        // Track node owners and HP before update for capture detection\n        const nodeOwnersBefore = new Map();\n        const nodeHpBefore = new Map();\n        const playerIdx = this.controller?.playerIndex ?? 0;\n\n        this.state.nodes.forEach(n => {\n            nodeOwnersBefore.set(n.id, n.owner);\n            nodeHpBefore.set(n.id, n.baseHp);\n        });\n\n        // Track entities before update for collision detection\n        // Use cached counts from previous frame (or init) to avoid O(N) filter\n        const playerEntitiesBefore = this.state.unitCounts ? (this.state.unitCounts[playerIdx] || 0) : 0;\n\n        this.state.update(dt, this);\n        if (this.controller && this.controller.update) {\n            this.controller.update(dt);\n        }\n        if (this.systems && this.systems.input) {\n            this.systems.input.update(dt);\n        }\n        this.particles = this.particles.filter(p => p.update(dt));\n        this.commandIndicators = this.commandIndicators.filter(ci => ci.update(dt));\n        this.waypointLines = this.waypointLines.filter(wl => wl.update(dt));\n\n        // Only play sounds if we have a valid player index (>= 0)\n        const isValidPlayer = playerIdx >= 0;\n\n        // Check for node captures - ONLY FOR OUR NODES\n        this.state.nodes.forEach(n => {\n            const oldOwner = nodeOwnersBefore.get(n.id);\n\n            // Node was captured by US (from neutral)\n            if (isValidPlayer && oldOwner !== undefined && oldOwner === -1 && n.owner === playerIdx) {\n                sounds.playCapture();\n            }\n        });\n\n        // Check for OUR cell collisions - play when OUR units die\n        const playerEntitiesNow = this.state.unitCounts ? (this.state.unitCounts[playerIdx] || 0) : 0;\n\n        // If OUR units died, play collision sound\n        if (playerEntitiesNow < playerEntitiesBefore && isValidPlayer) {\n            sounds.playCollision();\n        }\n    }\n\n    draw(dt) {\n        const playerIdx = this.controller?.playerIndex ?? 0;\n        this.renderer.setPlayerIndex(playerIdx);\n\n        this.renderer.clear(this.canvas.width, this.canvas.height);\n        this.renderer.drawGrid(this.canvas.width, this.canvas.height, this.camera);\n\n        this.state.nodes.forEach(node => {\n            const isSelected = this.systems?.selection?.isSelected(node);\n            this.renderer.drawNode(node, this.camera, isSelected);\n        });\n\n        // First pass: Queue and draw trails (batch rendered for performance)\n        this.state.entities.forEach(entity => {\n            const isSelected = this.systems?.selection?.isSelected(entity);\n            this.renderer.drawEntity(entity, this.camera, isSelected);\n        });\n        this.renderer.renderTrails(this.camera, dt);\n\n        // Third pass (already done by drawEntity): Bodies\n        // Wait, my drawEntity already draws the bodies. \n        // So trails will be ON TOP unless I restructure more.\n        // User said \"bolota\", glowing clouds look fine on top or bottom.\n        // Let's keep it as is for simplicity, or move trails before entities.\n\n        this.particles.forEach(p => this.renderer.drawParticle(p, this.camera));\n        this.commandIndicators.forEach(ci => this.renderer.drawCommandIndicator(ci, this.camera));\n\n        // Only show waypoint lines for our player\n        this.waypointLines.filter(wl => wl.owner === playerIdx).forEach(wl => this.renderer.drawWaypointLine(wl, this.camera));\n\n        // Draw selection box\n        if (this.systems.selection.isSelectingBox) {\n            const input = this.systems.input;\n            this.renderer.drawSelectionBox(\n                this.systems.selection.boxStart.x,\n                this.systems.selection.boxStart.y,\n                input.mouse.x,\n                input.mouse.y\n            );\n        }\n\n        // Draw current drawing path\n        if (this.systems.selection.currentPath.length > 0) {\n            this.renderer.drawPath(this.systems.selection.currentPath, this.camera, 'rgba(255, 255, 255, 0.6)', 3);\n        }\n\n        // Draw waypoints for selected units (only our own)\n        this.state.entities.filter(e => e.owner === playerIdx).forEach(e => {\n            if (this.systems.selection.isSelected(e) && e.waypoints.length > 0) {\n                // Combine current position with waypoints for a complete line\n                this.renderer.drawPath([e, ...e.waypoints], this.camera, 'rgba(255, 255, 255, 0.15)', 1.2, true);\n\n                // Draw a small indicator at the current target\n                const target = e.currentTarget || e.waypoints[0];\n                const screen = this.camera.worldToScreen(target.x, target.y);\n                this.ctx.beginPath();\n                this.ctx.arc(screen.x, screen.y, 2 * this.camera.zoom, 0, Math.PI * 2);\n                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n                this.ctx.fill();\n            }\n        });\n\n        // Draw HUD/UI via systems if initialized\n        if (this.systems && this.systems.ui) {\n            this.systems.ui.draw(this.renderer);\n        }\n    }\n\n    spawnCommandIndicator(x, y, type) {\n        // Simple indicator logic\n        const ci = {\n            x, y, type, life: 1.0, maxLife: 1.0,\n            update: function (dt) { this.life -= dt; return this.life > 0; }\n        };\n        this.commandIndicators.push(ci);\n    }\n\n    spawnWaypointLine(points, owner) {\n        const wl = {\n            points, owner, life: 2.0, maxLife: 2.0,\n            update: function (dt) { this.life -= dt; return this.life > 0; }\n        };\n        this.waypointLines.push(wl);\n    }\n\n    spawnParticles(x, y, color, count, type) {\n        if (this.particles.length > 100) return; // Hard cap on particles for performance\n        for (let i = 0; i < count; i++) {\n            this.particles.push(new Particle(x, y, color, Math.random() * 2 + 1, type));\n        }\n    }\n}\n","export class Particle {\n    constructor(x, y, color, size, type) {\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.size = size;\n        this.type = type;\n        this.life = 1.0;\n        this.maxLife = 1.0;\n        this.vx = (Math.random() - 0.5) * 100;\n        this.vy = (Math.random() - 0.5) * 100;\n        if (type === 'hit') {\n            this.life = 0.3;\n            this.maxLife = 0.3;\n        }\n    }\n\n    update(dt) {\n        this.x += this.vx * dt;\n        this.y += this.vy * dt;\n        this.life -= dt;\n        return this.life > 0;\n    }\n}\n","import { PLAYER_COLORS, GAME_SETTINGS } from '../../shared/GameConfig.js';\nimport { hexToRgba } from '../utils/helpers.js';\n\nexport class Renderer {\n    constructor(ctx, game) {\n        this.ctx = ctx;\n        this.game = game;\n        this.playerIndex = 0;\n        this.trailQueue = []; // Current frame units (kept for legacy support if needed)\n\n        // Pre-rendered glow cache for each player color\n        // Key: \"#RRGGBB\", Value: { canvas, size }\n        this.glowCache = new Map();\n\n        // High-performance unit sprite cache\n        this.unitSpriteCache = new Map();\n\n        // High-performance particle sprite cache\n        this.particleSpriteCache = new Map();\n    }\n\n    /**\n     * Pre-render unit sprite for a player color\n     * Creates an offscreen canvas with the unit circle, shadow, and highlight cached\n     */\n    _getOrCreateUnitSprite(color, radius) {\n        // Round radius to avoid creating too many cache entries for slight zoom changes\n        const r = Math.round(radius);\n        const key = `${color}_${r}`;\n\n        if (this.unitSpriteCache.has(key)) {\n            return this.unitSpriteCache.get(key);\n        }\n\n        // Create offscreen canvas with padding for shadow\n        const padding = 2;\n        const size = (r + padding) * 2;\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        const center = size / 2;\n\n        // 1. Shadow (minimal)\n        ctx.beginPath();\n        ctx.arc(center + 1, center + 1, r, 0, Math.PI * 2);\n        ctx.fillStyle = 'rgba(0,0,0,0.3)';\n        ctx.fill();\n\n        // 2. Unit Body\n        ctx.beginPath();\n        ctx.arc(center, center, r, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n\n        // 3. Highlight\n        ctx.beginPath();\n        ctx.arc(center - r * 0.3, center - r * 0.3, r * 0.4, 0, Math.PI * 2);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.fill();\n\n        this.unitSpriteCache.set(key, canvas);\n        return canvas;\n    }\n\n    /**\n     * Pre-render a generic particle sprite\n     * Keyed by color, using a fixed reference size for scaling\n     */\n    _getOrCreateParticleSprite(color) {\n        if (this.particleSpriteCache.has(color)) {\n            return this.particleSpriteCache.get(color);\n        }\n\n        const size = 32; // Fixed reference size\n        const center = size / 2;\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n\n        ctx.beginPath();\n        ctx.arc(center, center, (size / 2) - 1, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n\n        this.particleSpriteCache.set(color, canvas);\n        return canvas;\n    }\n\n    /**\n     * Pre-render glow sprite for a player color\n     * Creates an offscreen canvas with the glow effect cached\n     */\n    _getOrCreateGlow(color) {\n        if (this.glowCache.has(color)) {\n            return this.glowCache.get(color);\n        }\n\n        // Create offscreen canvas for the glow sprite\n        // Size: 64x64 for good resolution with some margin\n        const size = 64;\n        const center = size / 2;\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n\n        // Parse color components\n        const r = parseInt(color.slice(1, 3), 16);\n        const g = parseInt(color.slice(3, 5), 16);\n        const b = parseInt(color.slice(5, 7), 16);\n\n        // Create glow using radial gradient (once, not per frame!)\n        const gradient = ctx.createRadialGradient(center, center, 4, center, center, size / 2 - 2);\n        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.6)`);\n        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);\n        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n        ctx.fillStyle = gradient;\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.fillRect(0, 0, size, size);\n        ctx.globalCompositeOperation = 'source-over';\n\n        const glowData = { canvas, size };\n        this.glowCache.set(color, glowData);\n        return glowData;\n    }\n\n    setPlayerIndex(idx) {\n        this.playerIndex = idx;\n    }\n\n    clear(width, height) {\n        this.width = width;\n        this.height = height;\n        this.ctx.clearRect(0, 0, width, height); // Clear the entire canvas\n        this.trailQueue = []; // Reset for next frame\n        this.ctx.fillStyle = '#151515';\n        this.ctx.fillRect(0, 0, width, height);\n    }\n\n    drawGrid(width, height, camera) {\n        // Skip grid drawing if zoomed out too far (performance)\n        if (camera.zoom < 0.15) return;\n\n        const gridSize = 100 * camera.zoom;\n        const offsetX = (-camera.x * camera.zoom) % gridSize;\n        const offsetY = (-camera.y * camera.zoom) % gridSize;\n        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.015)';\n        this.ctx.lineWidth = 1;\n        for (let x = offsetX; x < width; x += gridSize) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, height);\n            this.ctx.stroke();\n        }\n        for (let y = offsetY; y < height; y += gridSize) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(width, y);\n            this.ctx.stroke();\n        }\n\n        // Map boundary ring - only visible when units approach\n        const worldRadius = GAME_SETTINGS.WORLD_RADIUS || 1800;\n        const centerX = (GAME_SETTINGS.WORLD_WIDTH || 2400) / 2;\n        const centerY = (GAME_SETTINGS.WORLD_HEIGHT || 1800) / 2;\n\n        // Only draw boundary if any unit is near it\n        let nearBoundary = false;\n        if (this.game && this.game.state && this.game.state.entities) {\n            for (const ent of this.game.state.entities) {\n                if (ent.dead || ent.dying) continue;\n                const dx = ent.x - centerX;\n                const dy = ent.y - centerY;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                if (dist > worldRadius - 300) {\n                    nearBoundary = true;\n                    break;\n                }\n            }\n        }\n\n        if (nearBoundary) {\n            const screenCenter = camera.worldToScreen(centerX, centerY);\n            const boundaryRadius = worldRadius * camera.zoom;\n\n            this.ctx.beginPath();\n            this.ctx.arc(screenCenter.x, screenCenter.y, boundaryRadius, 0, Math.PI * 2);\n            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n            this.ctx.lineWidth = 3;\n            this.ctx.setLineDash([10 * camera.zoom, 20 * camera.zoom]);\n            this.ctx.stroke();\n            this.ctx.setLineDash([]);\n        }\n    }\n\n    drawNode(node, camera, isSelected = false) {\n        const screen = camera.worldToScreen(node.x, node.y);\n        const sr = node.radius * camera.zoom;\n        const sir = node.influenceRadius * camera.zoom;\n\n        // Culling for nodes - skip if completely off screen\n        const margin = sir * 2;\n        if (this.width && (screen.x < -margin || screen.x > this.width + margin || screen.y < -margin || screen.y > this.height + margin)) {\n            return;\n        }\n\n        const baseColor = node.getColor();\n\n        const c = baseColor.slice(1);\n        const areaColor = [parseInt(c.slice(0, 2), 16), parseInt(c.slice(2, 4), 16), parseInt(c.slice(4, 6), 16)].join(',');\n\n        // Aura - Optimized with sprite-based rendering and reduced alpha\n        const glowData = this._getOrCreateGlow(baseColor);\n        const auraAlpha = 0.05; // Reduced from 0.08 for \"subtle\" look\n\n        this.ctx.save();\n        this.ctx.globalAlpha = auraAlpha;\n        this.ctx.drawImage(\n            glowData.canvas,\n            screen.x - sir,\n            screen.y - sir,\n            sir * 2,\n            sir * 2\n        );\n        this.ctx.restore();\n\n        // Dashed border (kept as vector for sharpness, but subtle)\n        this.ctx.beginPath();\n        this.ctx.arc(screen.x, screen.y, sir, 0, Math.PI * 2);\n        this.ctx.strokeStyle = `rgba(${areaColor},0.2)`;\n        this.ctx.lineWidth = 1.2 * camera.zoom;\n        this.ctx.setLineDash([8 * camera.zoom, 6 * camera.zoom]);\n        this.ctx.stroke();\n        this.ctx.setLineDash([]);\n\n        // Rally Line - only show for our own nodes\n        if (node.rallyPoint && node.owner !== -1 && node.owner === this.playerIndex) {\n            const rx = (node.rallyPoint.x - camera.x) * camera.zoom;\n            const ry = (node.rallyPoint.y - camera.y) * camera.zoom;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screen.x, screen.y);\n            this.ctx.lineTo(rx, ry);\n            this.ctx.strokeStyle = `rgba(${areaColor},0.5)`;\n            this.ctx.setLineDash([4 * camera.zoom, 4 * camera.zoom]);\n            this.ctx.stroke();\n            this.ctx.setLineDash([]);\n            this.ctx.beginPath();\n            this.ctx.arc(rx, ry, 5 * camera.zoom, 0, Math.PI * 2);\n            this.ctx.fillStyle = `rgba(${areaColor},0.7)`;\n            this.ctx.fill();\n        }\n\n        // Spawn Progress - player color when full, white otherwise\n        if (node.owner !== -1 && node.spawnProgress > 0) {\n            const isFull = node.baseHp >= node.maxHp;\n\n            // Use player color when full, white otherwise\n            let progressColor = isFull ? baseColor : '#ffffff';\n\n            // If under enemy pressure, flash between red and normal\n            if (node.enemyPressure) {\n                const flash = Math.sin(Date.now() / 150) > 0;\n                progressColor = flash ? '#ff0000' : progressColor;\n            }\n\n            const lineWidth = isFull ? (3 * camera.zoom) : (2 * camera.zoom);\n\n            // Cap at 1.0 to prevent visual overflow/looping\n            let progress = Math.min(1.0, node.spawnProgress);\n\n            // VISUAL FIX: If node just spawned (spawnEffect high), show full ring\n            // This prevents the \"99% -> 0%\" visual gap, making it feel perfectly synced\n            if (node.spawnEffect > 0.3) {\n                progress = 1.0;\n            }\n\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, sr + 5 * camera.zoom, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);\n            this.ctx.strokeStyle = progressColor;\n            this.ctx.lineWidth = lineWidth;\n            this.ctx.stroke();\n        }\n\n        // Node Body (Radial Fill)\n        const totalHp = node.getTotalHp();\n        const hpPercent = Math.max(0, Math.min(1, totalHp / node.maxHp));\n        const currentRadius = sr * hpPercent;\n\n        const r = parseInt(baseColor.slice(1, 3), 16);\n        const g = parseInt(baseColor.slice(3, 5), 16);\n        const b = parseInt(baseColor.slice(5, 7), 16);\n\n        let brightness = 1;\n        if (node.owner !== -1) {\n            brightness = 1 + Math.min(totalHp * 0.01, 0.5); // Subtle brightness based on hp\n        } else {\n            brightness = 1 + (node.baseHp / node.maxHp) * 0.3;\n        }\n        const brightColor = `rgb(${Math.min(255, r * brightness)}, ${Math.min(255, g * brightness)}, ${Math.min(255, b * brightness)})`;\n\n        // Background / Capacity indicator\n        this.ctx.beginPath();\n        this.ctx.arc(screen.x, screen.y, sr, 0, Math.PI * 2);\n        this.ctx.fillStyle = 'rgba(40,40,40,0.4)';\n        this.ctx.fill();\n        this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';\n        this.ctx.lineWidth = 1 * camera.zoom;\n        this.ctx.stroke();\n\n        if (hpPercent > 0) {\n            const grad = this.ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, currentRadius);\n            grad.addColorStop(0, `rgba(${r * 0.8}, ${g * 0.8}, ${b * 0.8}, 1)`);\n            grad.addColorStop(1, brightColor);\n\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, currentRadius, 0, Math.PI * 2);\n            this.ctx.fillStyle = grad;\n            this.ctx.fill();\n        }\n\n        const borderColorStr = isSelected ? 'rgba(255,255,255,0.9)' : `rgba(${areaColor},0.5)`;\n        this.ctx.beginPath();\n        this.ctx.arc(screen.x, screen.y, sr, 0, Math.PI * 2);\n        this.ctx.strokeStyle = borderColorStr;\n        this.ctx.lineWidth = isSelected ? 3 * camera.zoom : 1.5 * camera.zoom;\n        this.ctx.stroke();\n\n        if (node.hitFlash > 0) {\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, sr, 0, Math.PI * 2);\n            this.ctx.strokeStyle = `rgba(255,100,100,${node.hitFlash})`;\n            this.ctx.lineWidth = 5 * camera.zoom;\n            this.ctx.stroke();\n        }\n        if (node.spawnEffect > 0) {\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, sr * (1.3 + (0.5 - node.spawnEffect) * 0.6), 0, Math.PI * 2);\n            this.ctx.strokeStyle = `rgba(255,255,255,${node.spawnEffect * 1.5})`;\n            this.ctx.lineWidth = 3 * camera.zoom;\n            this.ctx.stroke();\n        }\n    }\n\n    drawEntity(entity, camera, isSelected = false) {\n        if (entity.dead) return;\n        const screen = camera.worldToScreen(entity.x, entity.y);\n        const margin = entity.radius * camera.zoom + 5;\n\n        // Culling: If off screen, skip drawing (Performance)\n        if (this.width && (\n            screen.x < -margin || screen.x > this.width + margin ||\n            screen.y < -margin || screen.y > this.height + margin\n        )) {\n            return;\n        }\n\n        // Dying animation handling\n        if (entity.dying) {\n            const progress = entity.deathTime / 0.4;\n            const sr = entity.radius * camera.zoom;\n            if (entity.deathType === 'explosion') {\n                const maxRadius = sr * 4;\n                const currentRadius = sr + (maxRadius - sr) * progress;\n                const alpha = 1 - progress;\n\n                this.ctx.beginPath();\n                this.ctx.arc(screen.x, screen.y, currentRadius, 0, Math.PI * 2);\n                this.ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.3})`;\n                this.ctx.fill();\n\n                this.ctx.beginPath();\n                this.ctx.arc(screen.x, screen.y, sr * (1 - progress * 0.8), 0, Math.PI * 2);\n                this.ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;\n                this.ctx.fill();\n            } else if (entity.deathType === 'attack') {\n                const flash = Math.sin(progress * Math.PI * 6) * 0.5 + 0.5;\n                this.ctx.beginPath();\n                this.ctx.arc(screen.x, screen.y, sr * (1 + progress * 2), 0, Math.PI * 2);\n                this.ctx.fillStyle = `rgba(255, 100, 100, ${flash * 0.4 * (1 - progress)})`;\n                this.ctx.fill();\n            } else if (entity.deathType === 'sacrifice' && entity.absorbTarget) {\n                const node = entity.absorbTarget;\n                const easeProgress = progress * progress;\n                const currentX = entity.x + (node.x - entity.x) * easeProgress;\n                const currentY = entity.y + (node.y - entity.y) * easeProgress;\n                const absorbScreen = camera.worldToScreen(currentX, currentY);\n                const currentRadius = sr * (1 - progress * 0.7);\n                const alpha = 1 - progress;\n\n                const playerColor = PLAYER_COLORS[entity.owner % PLAYER_COLORS.length];\n                const r = parseInt(playerColor.slice(1, 3), 16);\n                const g = parseInt(playerColor.slice(3, 5), 16);\n                const b = parseInt(playerColor.slice(5, 7), 16);\n\n                this.ctx.save();\n                this.ctx.globalCompositeOperation = 'lighter';\n                this.ctx.beginPath();\n                this.ctx.arc(absorbScreen.x, absorbScreen.y, currentRadius, 0, Math.PI * 2);\n                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;\n                this.ctx.fill();\n                this.ctx.restore();\n            }\n            return;\n        }\n\n        const playerColor = PLAYER_COLORS[entity.owner % PLAYER_COLORS.length];\n        const renderRadius = entity.radius * camera.zoom;\n\n        // Optimization: Image-based rendering with cached sprites\n        const sprite = this._getOrCreateUnitSprite(playerColor, renderRadius);\n        const offset = sprite.width / 2;\n\n        // Quick draw using drawImage (Bit blit is much faster than ctx.arc fill)\n        this.ctx.drawImage(sprite, (screen.x - offset) | 0, (screen.y - offset) | 0);\n\n        // Selection circle\n        if (isSelected) {\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, renderRadius + 2, 0, Math.PI * 2);\n            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';\n            this.ctx.lineWidth = 1;\n            this.ctx.stroke();\n        }\n\n        // Speed Boost Glow - Restored and unconditionally enabled for visual satisfaction\n        const smoothedBoost = entity.speedBoost * entity.speedBoost;\n        if (smoothedBoost > 0.1) {\n            const glowData = this._getOrCreateGlow(playerColor);\n            const glowRadius = renderRadius * (1.2 + smoothedBoost * 1.5);\n\n            this.ctx.save();\n            this.ctx.globalCompositeOperation = 'lighter';\n            // Reduced from 0.7 to 0.45 for a cleaner, less saturated screen\n            this.ctx.globalAlpha = smoothedBoost * 0.45;\n            this.ctx.drawImage(\n                glowData.canvas,\n                screen.x - glowRadius,\n                screen.y - glowRadius,\n                glowRadius * 2,\n                glowRadius * 2\n            );\n            this.ctx.restore();\n        }\n    }\n\n    renderTrails(camera, dt = 0.016) {\n        // Trails removed in favor of direct unit glow for \"satisfying\" and optimized visuals\n        this.trailQueue = [];\n    }\n\n    drawParticle(p, camera) {\n        if (p.life <= 0) return;\n        const screen = camera.worldToScreen(p.x, p.y);\n\n        // Culling\n        if (this.width && (screen.x < -20 || screen.x > this.width + 20 || screen.y < -20 || screen.y > this.height + 20)) {\n            return;\n        }\n\n        this.ctx.globalAlpha = p.life / p.maxLife;\n\n        if (p.type === 'hit') {\n            // Hit particles are lines, keeping vector for now as they are few, \n            // but optimized with globalAlpha\n            this.ctx.beginPath();\n            this.ctx.moveTo(screen.x, screen.y);\n            this.ctx.lineTo(screen.x - p.vx * 0.1, screen.y - p.vy * 0.1);\n            this.ctx.strokeStyle = p.color;\n            this.ctx.lineWidth = 2 * camera.zoom;\n            this.ctx.stroke();\n        } else {\n            // Explosions/Death particles: Sprite-based\n            const sprite = this._getOrCreateParticleSprite(p.color);\n            const renderSize = p.size * 1.2 * camera.zoom;\n\n            // Speed-based particle glow (Restore requested beauty)\n            const speedSq = p.vx * p.vx + p.vy * p.vy;\n            if (speedSq > 4000) { // Only for fast moving particles\n                const glowData = this._getOrCreateGlow(p.color);\n                const glowRadius = renderSize * 2.5;\n                this.ctx.save();\n                this.ctx.globalCompositeOperation = 'lighter';\n                this.ctx.globalAlpha = (p.life / p.maxLife) * 0.4;\n                this.ctx.drawImage(\n                    glowData.canvas,\n                    screen.x - glowRadius,\n                    screen.y - glowRadius,\n                    glowRadius * 2,\n                    glowRadius * 2\n                );\n                this.ctx.restore();\n            }\n\n            // Fast bit blit\n            this.ctx.drawImage(\n                sprite,\n                screen.x - renderSize / 2,\n                screen.y - renderSize / 2,\n                renderSize,\n                renderSize\n            );\n        }\n        this.ctx.globalAlpha = 1.0;\n    }\n\n    drawCommandIndicator(ci, camera) {\n        const screen = camera.worldToScreen(ci.x, ci.y);\n        const alpha = Math.max(0, ci.life / ci.maxLife);\n        const size = 10 * camera.zoom;\n\n        if (ci.type === 'attack') {\n            this.ctx.strokeStyle = `rgba(255, 100, 100, ${alpha})`;\n            this.ctx.lineWidth = 2 * camera.zoom;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screen.x - size, screen.y - size);\n            this.ctx.lineTo(screen.x + size, screen.y + size);\n            this.ctx.moveTo(screen.x + size, screen.y - size);\n            this.ctx.lineTo(screen.x - size, screen.y + size);\n            this.ctx.stroke();\n        } else {\n            this.ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;\n            this.ctx.lineWidth = 2 * camera.zoom;\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, size * (1 - alpha), 0, Math.PI * 2);\n            this.ctx.stroke();\n        }\n    }\n\n    drawSelectionBox(x1, y1, x2, y2) {\n        const x = Math.min(x1, x2), y = Math.min(y1, y2);\n        const w = Math.abs(x1 - x2), h = Math.abs(y1 - y2);\n        this.ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';\n        this.ctx.fillRect(x, y, w, h);\n        this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';\n        this.ctx.lineWidth = 1.5;\n        this.ctx.strokeRect(x, y, w, h);\n    }\n\n    drawPath(points, camera, color = 'rgba(255, 255, 255, 0.4)', lineWidth = 2, dashed = false) {\n        if (points.length < 2) return;\n        this.ctx.beginPath();\n        const start = camera.worldToScreen(points[0].x, points[0].y);\n        this.ctx.moveTo(start.x, start.y);\n        for (let i = 1; i < points.length; i++) {\n            const p = camera.worldToScreen(points[i].x, points[i].y);\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = lineWidth * camera.zoom;\n        if (dashed) this.ctx.setLineDash([5 * camera.zoom, 5 * camera.zoom]);\n        this.ctx.stroke();\n        if (dashed) this.ctx.setLineDash([]);\n    }\n\n    drawWaypointLine(wl, camera) {\n        if (wl.points.length < 2) return;\n        const alpha = Math.max(0, wl.life / wl.maxLife) * 0.7;\n        const color = PLAYER_COLORS[wl.owner % PLAYER_COLORS.length];\n\n        // Helper to convert hex to rgba\n        const r = parseInt(color.slice(1, 3), 16);\n        const g = parseInt(color.slice(3, 5), 16);\n        const b = parseInt(color.slice(5, 7), 16);\n        const rgba = `rgba(${r}, ${g}, ${b}, ${alpha})`;\n\n        this.ctx.lineWidth = 4 * camera.zoom;\n        this.ctx.setLineDash([8 * camera.zoom, 6 * camera.zoom]);\n        this.ctx.strokeStyle = rgba;\n\n        this.ctx.beginPath();\n        const start = camera.worldToScreen(wl.points[0].x, wl.points[0].y);\n        this.ctx.moveTo(start.x, start.y);\n\n        for (let i = 1; i < wl.points.length; i++) {\n            const p = camera.worldToScreen(wl.points[i].x, wl.points[i].y);\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.stroke();\n        this.ctx.setLineDash([]);\n\n        wl.points.forEach((point, i) => {\n            const screen = camera.worldToScreen(point.x, point.y);\n            this.ctx.beginPath();\n            this.ctx.arc(screen.x, screen.y, (i === wl.points.length - 1 ? 6 : 3) * camera.zoom, 0, Math.PI * 2);\n            this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha * (i === wl.points.length - 1 ? 1 : 0.6)})`;\n            this.ctx.fill();\n        });\n    }\n}\n","import { io } from 'socket.io-client';\nimport { Entity } from '../../shared/Entity.js';\nimport { Node } from '../../shared/Node.js';\nimport { GameState } from '../../shared/GameState.js';\nimport { sounds } from '../systems/SoundManager.js';\n\nexport class MultiplayerController {\n    constructor(game) {\n        this.game = game;\n        this.socket = null;\n        this.connected = false;\n        this.playerIndex = -1;\n        this.roomId = null;\n        this.cameraCentered = false;\n        this.initialStateReceived = false;\n        this.gameLost = false;\n        this.surrendered = false;\n        this.playerDefeated = false;\n    }\n\n    connect(url = '/') {\n        this.socket = io(url);\n        this.setupSocketEvents();\n        window.multiplayer = this;\n    }\n\n    surrender() {\n        if (this.socket && this.connected && !this.surrendered) {\n            this.surrendered = true;\n            this.socket.emit('surrender');\n            alert('Te has rendido. Puedes seguir jugando mientras esperas.');\n        }\n    }\n\n    setupSocketEvents() {\n        this.socket.on('connect', () => {\n            this.connected = true;\n            console.log('MultiplayerController connected to server');\n            this.socket.emit('listRooms');\n\n            const name = localStorage.getItem('nanowar_nickname');\n            if (name) this.socket.emit('setNickname', name);\n        });\n\n        this.socket.on('roomList', (rooms) => {\n            if (window.updateRoomListUI) {\n                window.updateRoomListUI(rooms);\n            }\n        });\n\n        this.socket.on('lobbyUpdate', (data) => {\n            console.log('Lobby Update:', data);\n            if (window.updateLobbyUI) {\n                window.updateLobbyUI(data.players);\n            }\n        });\n\n        this.socket.on('gameStart', (initialState) => {\n            console.log('Game starting!');\n\n            // Clear existing state and initialize from server\n            this.game.state = new GameState();\n            this.game.state.nodes = [];\n            this.game.state.entities = [];\n            this.game.state.playerCount = initialState.playerCount || this.game.state.playerCount;\n\n            // Apply initial state\n            if (initialState.nodes) {\n                initialState.nodes.forEach(sn => {\n                    const node = new Node(sn.id, sn.x, sn.y, sn.owner, sn.type);\n                    node.baseHp = sn.baseHp;\n                    node.maxHp = sn.maxHp;\n                    node.stock = sn.stock;\n                    node.maxStock = sn.maxStock;\n                    node.spawnProgress = sn.spawnProgress;\n                    if (sn.rallyPoint) node.rallyPoint = sn.rallyPoint;\n                    this.game.state.nodes.push(node);\n                });\n            }\n\n            // Spawn initial entities for all players - MORE units for multiplayer\n            this.game.state.nodes.forEach(node => {\n                if (node.owner !== -1) {\n                    for (let i = 0; i < 20; i++) {\n                        const angle = Math.random() * Math.PI * 2;\n                        const dist = node.radius + 30;\n                        const ent = new Entity(\n                            node.x + Math.cos(angle) * dist,\n                            node.y + Math.sin(angle) * dist,\n                            node.owner,\n                            Date.now() + i + (node.owner * 1000)\n                        );\n                        this.game.state.entities.push(ent);\n                    }\n                }\n            });\n\n            const lobby = document.getElementById('lobby-screen');\n            const gameScreen = document.getElementById('game-screen');\n            if (lobby) lobby.style.display = 'none';\n            if (gameScreen) gameScreen.style.display = 'block';\n\n            this.game.resize();\n            this.game.start();\n        });\n\n        this.socket.on('playerDefeated', (data) => {\n            const isMe = data.playerIndex === this.playerIndex;\n\n            if (isMe) {\n                this.playerDefeated = true;\n                // Show small notification\n                const notif = document.createElement('div');\n                notif.style.cssText = `\n                    position: fixed; top: 60px; left: 50%; transform: translateX(-50%);\n                    background: rgba(244,67,54,0.9); color: white; padding: 10px 20px;\n                    border-radius: 4px; z-index: 100; font-family: monospace;\n                `;\n                notif.textContent = data.surrendered ? 'TE RENDISTE - Solo puedes mover y atacar' : 'SIN NODOS - Solo puedes mover y atacar';\n                document.body.appendChild(notif);\n                setTimeout(() => notif.remove(), 3000);\n            }\n        });\n\n        this.socket.on('gameState', (serverState) => {\n            // Stop syncing after game over\n            if (this.game.gameOverShown) return;\n\n            // Keep syncing always for defeated players who can still play\n            if (this.game.running || this.playerDefeated) {\n                this.syncState(serverState);\n            }\n        });\n\n        this.socket.on('gameOver', (data) => {\n            const won = data.winner === this.playerIndex;\n            const lost = data.winner !== -1 && data.winner !== this.playerIndex;\n\n            // Keep game running even if lost - players can still move units\n            this.gameLost = lost;\n\n            // Mark game as over to stop receiving states\n            if (this.game) this.game.gameOverShown = true;\n\n            // Play win/lose sound\n            if (won) {\n                sounds.playWin();\n            } else {\n                sounds.playLose();\n            }\n\n            // Show overlay\n            const msg = won ? 'VICTORIA!' : (data.winner === -1 ? 'EMPATE' : 'DERROTA');\n            const color = won ? '#4CAF50' : '#f44336';\n\n            const playerColors = ['#4CAF50', '#f44336', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4'];\n\n            // Generate stats HTML\n            let statsHTML = '<div style=\"margin: 20px 0; text-align: left; font-size: 12px;\">';\n\n            const stats = data.stats || this.game.state.getStats();\n\n            if (stats && stats.produced) {\n                statsHTML += `<p style=\"color: #888; margin-bottom: 10px;\">Duracin: ${Math.floor(stats.elapsed)}m ${Math.floor((stats.elapsed % 1) * 60)}s</p>`;\n\n                for (let pid in stats.produced) {\n                    const p = parseInt(pid);\n                    const pColor = playerColors[p % playerColors.length];\n                    const pName = p === this.playerIndex ? 'T' : `Jugador ${p + 1}`;\n                    const produced = stats.produced[pid]?.total || 0;\n                    const lostUnits = stats.lost[pid]?.total || 0;\n                    const current = stats.current[pid] || 0;\n                    const prodPerMin = stats.produced[pid]?.perMinute || 0;\n\n                    const captured = stats.captured[pid] || 0;\n\n                    statsHTML += `\n                        <div style=\"color: ${pColor}; margin: 8px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid ${pColor};\">\n                            <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;\">\n                                <strong style=\"font-size: 14px;\">${pName}</strong>\n                                <span style=\"font-size: 10px; opacity: 0.7;\">CAPTURAS: ${captured}</span>\n                            </div>\n                            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 11px; opacity: 0.8;\">\n                                <span>Producidas: ${produced}</span>\n                                <span>Promedio: ${prodPerMin}/m</span>\n                                <span>Perdidas: ${lostUnits}</span>\n                                <span>Actuales: ${current}</span>\n                            </div>\n                        </div>\n                    `;\n                }\n            }\n            statsHTML += '</div>';\n\n            // Generate graph UI\n            const graphWidth = 500;\n            const graphHeight = 200;\n\n            let graphUI = `\n                <div style=\"margin: 15px 0;\">\n                    <div style=\"display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;\">\n                        <button id=\"btn-graph-prod\" onclick=\"window.updateGraph('production')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Produccin</button>\n                        <button id=\"btn-graph-units\" onclick=\"window.updateGraph('units')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Unidades</button>\n                        <button id=\"btn-graph-nodes\" onclick=\"window.updateGraph('nodes')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Territorio</button>\n                    </div>\n                    <div style=\"position: relative;\">\n                        <canvas id=\"stats-graph\" width=\"${graphWidth}\" height=\"${graphHeight}\" style=\"border: 1px solid #333; background: rgba(0,0,0,0.3); border-radius: 4px;\"></canvas>\n                        <button onclick=\"window.downloadGraph()\" style=\"position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 3px; font-size: 10px; padding: 4px 8px; cursor: pointer;\"> IMG</button>\n                    </div>\n                </div>\n            `;\n\n            const overlay = document.createElement('div');\n            overlay.id = 'game-over-overlay';\n            overlay.style.cssText = `\n                position: fixed; top: 0; left: 0; right: 0; bottom: 0;\n                background: rgba(0,0,0,0.85); display: flex;\n                justify-content: center; align-items: center; z-index: 1000;\n            `;\n\n            const box = document.createElement('div');\n            box.style.cssText = `\n                padding: 40px 60px; background: #141419;\n                border: 3px solid ${color}; border-radius: 12px;\n                text-align: center; position: relative;\n            `;\n\n            box.innerHTML = `\n                <button onclick=\"this.parentElement.parentElement.remove(); location.href='index.html';\" style=\"\n                    position: absolute; top: 10px; right: 15px;\n                    background: none; border: none; color: #888;\n                    font-size: 24px; cursor: pointer; line-height: 1;\n                \">&times;</button>\n                <h1 style=\"color: ${color}; font-size: 48px; margin: 0 0 20px 0; letter-spacing: 4px;\">${msg}</h1>\n                ${graphUI}\n                ${statsHTML}\n                <p style=\"color: #888; margin-bottom: 20px;\">${lost ? 'Puedes seguir jugando mientras esperas...' : ''}</p>\n                <button id=\"restart-btn\" style=\"\n                    background: ${color}; color: white; border: none;\n                    padding: 12px 30px; font-size: 16px; cursor: pointer;\n                    border-radius: 4px; font-family: 'Courier New', monospace;\n                \">VOLVER AL MENU</button>\n            `;\n\n            overlay.appendChild(box);\n            document.body.appendChild(overlay);\n\n            // Define graph update function globally so buttons can call it\n            window.updateGraph = (type) => {\n                const canvas = document.getElementById('stats-graph');\n                if (!canvas) return;\n                const ctx = canvas.getContext('2d');\n                const w = canvas.width;\n                const h = canvas.height;\n\n                ctx.clearRect(0, 0, w, h);\n\n                let dataArray = [];\n                let title = '';\n                let timeScale = 1; // Divide time by this to get minutes\n\n                // Update active button style\n                ['prod', 'units', 'nodes'].forEach(t => {\n                    const btn = document.getElementById(`btn-graph-${t}`);\n                    if (btn) btn.style.borderColor = t === type ? color : '#444';\n                    if (btn) btn.style.color = t === type ? color : '#888';\n                });\n\n                if (type === 'production') {\n                    dataArray = stats.productionHistory || [];\n                    title = 'PRODUCCIN (Unidades/Min)';\n                    timeScale = 1; // Already in minutes\n                } else if (type === 'units') {\n                    dataArray = stats.history || [];\n                    title = 'EJRCITO TOTAL';\n                    timeScale = 60; // Seconds to minutes\n                } else if (type === 'nodes') {\n                    dataArray = stats.nodeHistory || [];\n                    title = 'TERRITORIO (Nodos)';\n                    timeScale = 60; // Seconds to minutes\n                }\n\n                if (!dataArray || dataArray.length === 0) {\n                    ctx.fillStyle = '#444';\n                    ctx.textAlign = 'center';\n                    ctx.fillText('No hay datos disponibles', w / 2, h / 2);\n                    return;\n                }\n\n                // Find max value\n                let maxVal = 0;\n                dataArray.forEach(p => {\n                    const val = p.rate !== undefined ? p.rate : p.count;\n                    if (val > maxVal) maxVal = val;\n                });\n                maxVal = Math.ceil(Math.max(maxVal, 5) * 1.1); // Min 5, 10% padding\n\n                // Draw Grid\n                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                for (let i = 0; i <= 4; i++) {\n                    const y = h - (i / 4) * h * 0.9 - 5;\n                    ctx.moveTo(0, y);\n                    ctx.lineTo(w, y);\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n                    ctx.font = '10px monospace';\n                    ctx.fillText(Math.round((i / 4) * maxVal), 5, y - 2);\n                }\n                ctx.stroke();\n\n                // Group by player\n                const playerData = {};\n                dataArray.forEach(p => {\n                    if (!playerData[p.playerId]) playerData[p.playerId] = [];\n                    playerData[p.playerId].push(p);\n                });\n\n                // Draw Lines\n                const playerColors = ['#4CAF50', '#f44336', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4'];\n\n                for (let pid in playerData) {\n                    const data = playerData[pid];\n                    data.sort((a, b) => a.time - b.time);\n\n                    const pC = playerColors[parseInt(pid) % playerColors.length];\n                    ctx.strokeStyle = pC;\n                    ctx.lineWidth = 2;\n                    ctx.lineJoin = 'round';\n                    ctx.beginPath();\n\n                    data.forEach((p, i) => {\n                        const val = p.rate !== undefined ? p.rate : p.count;\n                        const t = (p.time / timeScale);\n                        const x = (t / (stats.elapsed || 1)) * w;\n                        const y = h - (val / maxVal) * h * 0.9 - 5;\n\n                        if (i === 0) ctx.moveTo(x, y);\n                        else ctx.lineTo(x, y);\n                    });\n                    ctx.stroke();\n\n                    if (data.length < 50) {\n                        ctx.fillStyle = pC;\n                        data.forEach(p => {\n                            const val = p.rate !== undefined ? p.rate : p.count;\n                            const t = (p.time / timeScale);\n                            const x = (t / (stats.elapsed || 1)) * w;\n                            const y = h - (val / maxVal) * h * 0.9 - 5;\n                            ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();\n                        });\n                    }\n                }\n\n                // Title\n                ctx.fillStyle = '#888';\n                ctx.font = '12px monospace';\n                ctx.textAlign = 'center';\n                ctx.fillText(title, w / 2, 15);\n            };\n\n            window.downloadGraph = () => {\n                const canvas = document.getElementById('stats-graph');\n                if (canvas) {\n                    const link = document.createElement('a');\n                    link.download = `nanowar-stats-${Date.now()}.png`;\n                    link.href = canvas.toDataURL();\n                    link.click();\n                }\n            };\n\n            // Draw initial graph\n            setTimeout(() => {\n                window.updateGraph('production');\n            }, 100);\n\n            // Click outside to close\n            overlay.addEventListener('click', (e) => {\n                if (e.target === overlay) {\n                    overlay.remove();\n                    location.href = 'index.html';\n                }\n            });\n\n            document.getElementById('restart-btn').addEventListener('click', () => {\n                overlay.remove();\n                location.reload();\n            });\n        });\n\n        this.socket.on('disconnect', () => {\n            this.connected = false;\n        });\n    }\n\n    createRoom(maxPlayers = 4) {\n        this.socket.emit('createRoom', { maxPlayers }, (response) => {\n            if (response.success) {\n                this.roomId = response.roomId;\n                this.playerIndex = response.playerIndex;\n                this.showLobby();\n            }\n        });\n    }\n\n    joinRoom(roomId) {\n        this.socket.emit('joinRoom', { roomId }, (response) => {\n            if (response.success) {\n                this.roomId = roomId;\n                this.playerIndex = response.playerIndex;\n                this.showLobby();\n            } else {\n                alert('Error: ' + response.message);\n            }\n        });\n    }\n\n    toggleReady() {\n        // Get settings from lobby UI\n        const speedSetting = document.getElementById('speed-setting');\n\n        const productionSetting = document.getElementById('production-setting');\n\n        const settings = {\n            speedMultiplier: speedSetting ? parseFloat(speedSetting.value) : 1,\n            acceleration: false,\n            showProduction: productionSetting ? productionSetting.checked : true\n        };\n\n        if (this.socket) this.socket.emit('toggleReady', settings);\n    }\n\n    showLobby() {\n        const lobby = document.getElementById('lobby-screen');\n        const menu = document.getElementById('menu-screen');\n        if (lobby) lobby.style.display = 'block';\n        if (menu) menu.style.display = 'none';\n    }\n\n    sendAction(action) {\n        if (this.socket && this.connected) {\n            this.socket.emit('gameAction', action);\n        }\n    }\n\n    syncState(serverState) {\n        // Sync nodes\n        serverState.nodes.forEach(sn => {\n            let clientNode = this.game.state.nodes.find(cn => cn.id === sn.id);\n            if (!clientNode) {\n                clientNode = new Node(sn.id, sn.x, sn.y, sn.owner, sn.type);\n                this.game.state.nodes.push(clientNode);\n            }\n\n            // Check if node was captured\n            const oldOwner = clientNode.owner;\n\n            // Update properties from server (ensure maxHp is synced to fix visual fill issues)\n            clientNode.owner = sn.owner;\n            clientNode.baseHp = sn.baseHp;\n            clientNode.maxHp = sn.maxHp;\n            clientNode.radius = sn.radius;\n            clientNode.influenceRadius = sn.influenceRadius;\n            clientNode.stock = sn.stock;\n            clientNode.spawnProgress = sn.spawnProgress;\n            clientNode.hitFlash = sn.hitFlash;\n            clientNode.spawnEffect = sn.spawnEffect;\n            clientNode.enemyPressure = sn.enemyPressure;\n            if (sn.rallyPoint) {\n                clientNode.rallyPoint = sn.rallyPoint;\n            }\n\n            // Play capture sound ONLY if WE captured it\n            if (oldOwner !== sn.owner && sn.owner === this.playerIndex) {\n                sounds.playCapture();\n            }\n        });\n\n        // Center camera on player's starting node\n        if (!this.cameraCentered && this.playerIndex !== -1 && this.game.state.nodes.length > 0) {\n            const startNode = this.game.state.nodes.find(n => n.owner === this.playerIndex);\n            if (startNode) {\n                this.game.camera.centerOn(startNode.x, startNode.y, this.game.canvas.width, this.game.canvas.height);\n                this.cameraCentered = true;\n            }\n        }\n\n        // Sync entities - update existing ones\n        const entityMap = new Map();\n        this.game.state.entities.forEach(e => entityMap.set(e.id, e));\n\n        serverState.entities.forEach(se => {\n            let ent = entityMap.get(se.id);\n            if (!ent) {\n                ent = new Entity(se.x, se.y, se.owner, se.id);\n                this.game.state.entities.push(ent);\n            }\n\n            // Update from server (authoritative)\n            ent.x = se.x;\n            ent.y = se.y;\n            ent.vx = se.vx;\n            ent.vy = se.vy;\n            ent.owner = se.owner;\n            ent.dying = se.dying;\n            ent.deathType = se.deathType;\n            ent.deathTime = se.deathTime;\n\n            entityMap.set(se.id, ent);\n        });\n\n        // Remove entities that no longer exist on server\n        const serverEntityIds = new Set(serverState.entities.map(e => e.id));\n        this.game.state.entities = this.game.state.entities.filter(e => serverEntityIds.has(e.id));\n\n        // Sync elapsed time\n        if (serverState.elapsedTime !== undefined) {\n            this.game.state.elapsedTime = serverState.elapsedTime;\n        }\n\n        // Sync game settings\n        if (serverState.speedMultiplier !== undefined) {\n            this.game.state.speedMultiplier = serverState.speedMultiplier;\n        }\n        if (serverState.accelerationEnabled !== undefined) {\n            this.game.state.accelerationEnabled = serverState.accelerationEnabled;\n        }\n        if (serverState.showProduction !== undefined) {\n            this.game.state.showProduction = serverState.showProduction;\n        }\n    }\n}\n","import { AIController } from '../../shared/AIController.js';\nimport { Node } from '../../shared/Node.js';\nimport { Entity } from '../../shared/Entity.js';\nimport { MapGenerator } from '../../shared/MapGenerator.js';\nimport { sounds } from '../systems/SoundManager.js';\n\nexport class SingleplayerController {\n    constructor(game) {\n        this.game = game;\n        this.ais = [];\n        this.gameOverShown = false;\n    }\n\n    setup(playerCount = 1, difficulty = 'intermediate', testMode = false) {\n        this.game.state.playerCount = playerCount;\n\n        // In test mode, force 4 players (1 human + 3 AI) on easy\n        if (testMode) {\n            this.game.state.playerCount = 4;\n            difficulty = 'easy';\n        }\n\n        this.game.state.difficulty = difficulty;\n        this.testMode = testMode;\n        this.playerIndex = 0;\n        this.createLevel();\n        this.createInitialEntities(testMode);\n\n        const difficultyMap = {\n            'easy': 'Easy',\n            'intermediate': 'Normal',\n            'hard': 'Hard',\n            'expert': 'Nightmare'\n        };\n\n        // Create AIs for CPUs (indices > 0)\n        for (let i = 1; i < playerCount; i++) {\n            const aiDifficulty = difficultyMap[difficulty] || 'Normal';\n            this.ais.push(new AIController(this.game, i, aiDifficulty));\n        }\n    }\n\n    createLevel() {\n        const width = this.game.state.worldWidth;\n        const height = this.game.state.worldHeight;\n        this.game.state.nodes = MapGenerator.generate(this.game.state.playerCount, width, height);\n    }\n\n    createInitialEntities(testMode = false) {\n        const initialCount = testMode ? 1000 : 15;\n\n        this.game.state.nodes.forEach(node => {\n            if (node.owner !== -1) {\n                for (let i = 0; i < initialCount; i++) {\n                    // Spawn units tightly clustered around the node center\n                    const angle = Math.random() * Math.PI * 2;\n                    const dist = Math.random() * (node.radius + 20);\n                    const ent = new Entity(\n                        node.x + Math.cos(angle) * dist,\n                        node.y + Math.sin(angle) * dist,\n                        node.owner,\n                        Date.now() + i + (node.owner * 10000)\n                    );\n                    this.game.state.entities.push(ent);\n                }\n            }\n        });\n    }\n\n    update(dt) {\n        this.ais.forEach(ai => ai.update(dt));\n\n        if (this.gameOverShown) return;\n\n        const playerNodes = this.game.state.nodes.filter(n => n.owner === 0);\n        const enemyNodes = this.game.state.nodes.filter(n => n.owner > 0);\n\n        // Victory/defeat based on nodes only (units don't matter)\n        const playerHasNodes = playerNodes.length > 0;\n        const enemiesHaveNodes = enemyNodes.length > 0;\n\n        if (!playerHasNodes) {\n            this.showGameOver(false);\n        } else if (!enemiesHaveNodes) {\n            this.showGameOver(true);\n        }\n    }\n\n    showGameOver(won) {\n        this.gameOverShown = true;\n        this.game.gameOverShown = true;\n\n        if (won) {\n            sounds.playWin();\n        } else {\n            sounds.playLose();\n        }\n\n        const msg = won ? 'VICTORIA!' : 'DERROTA';\n        const color = won ? '#4CAF50' : '#f44336';\n        const playerColors = ['#4CAF50', '#f44336', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4', '#FFEB3B', '#E91E63'];\n\n        // Generate stats HTML\n        let statsHTML = '<div style=\"margin: 20px 0; text-align: left; font-size: 12px; max-height: 200px; overflow-y: auto;\">';\n\n        const stats = this.game.state.getStats();\n\n        if (stats && stats.produced) {\n            statsHTML += `<p style=\"color: #888; margin-bottom: 10px;\">Duracin: ${Math.floor(stats.elapsed)}m ${Math.floor((stats.elapsed % 1) * 60)}s</p>`;\n\n            for (let pid in stats.produced) {\n                const p = parseInt(pid);\n                const pColor = playerColors[p % playerColors.length];\n                const pName = p === 0 ? 'T' : `CPU ${p}`;\n                const produced = stats.produced[pid]?.total || 0;\n                const lostUnits = stats.lost[pid]?.total || 0;\n                const current = stats.current[pid] || 0;\n                const captured = stats.captured[pid] || 0;\n                const prodPerMin = stats.produced[pid]?.perMinute || 0;\n\n                statsHTML += `\n                    <div style=\"color: ${pColor}; margin: 8px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid ${pColor};\">\n                        <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;\">\n                            <strong style=\"font-size: 14px;\">${pName}</strong>\n                            <span style=\"font-size: 10px; opacity: 0.7;\">CAPTURAS: ${captured}</span>\n                        </div>\n                        <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 11px; opacity: 0.8;\">\n                            <span>Producidas: ${produced}</span>\n                            <span>Promedio: ${prodPerMin}/m</span>\n                            <span>Perdidas: ${lostUnits}</span>\n                            <span>Actuales: ${current}</span>\n                        </div>\n                    </div>\n                `;\n            }\n        }\n        statsHTML += '</div>';\n\n        // Generate graph\n        // ... existing stats HTML generation ...\n\n        // Generate graph UI\n        const graphWidth = 500;\n        const graphHeight = 200;\n\n        let graphUI = `\n            <div style=\"margin: 15px 0;\">\n                <div style=\"display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;\">\n                    <button id=\"btn-graph-prod\" onclick=\"window.updateGraph('production')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Produccin</button>\n                    <button id=\"btn-graph-units\" onclick=\"window.updateGraph('units')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Unidades</button>\n                    <button id=\"btn-graph-nodes\" onclick=\"window.updateGraph('nodes')\" style=\"background: rgba(255,255,255,0.1); border: 1px solid #444; color: #888; padding: 5px 10px; cursor: pointer; border-radius: 4px;\">Territorio</button>\n                </div>\n                <div style=\"position: relative;\">\n                    <canvas id=\"stats-graph-sp\" width=\"${graphWidth}\" height=\"${graphHeight}\" style=\"border: 1px solid #333; background: rgba(0,0,0,0.3); border-radius: 4px;\"></canvas>\n                    <button onclick=\"window.downloadGraph()\" style=\"position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 3px; font-size: 10px; padding: 4px 8px; cursor: pointer;\"> IMG</button>\n                </div>\n            </div>\n        `;\n\n        const overlay = document.createElement('div');\n        overlay.id = 'game-over-overlay';\n        overlay.style.cssText = `\n            position: fixed; top: 0; left: 0; width: 100%; height: 100%;\n            background: rgba(0,0,0,0.9); z-index: 1000;\n            display: flex; flex-direction: column;\n            align-items: center; justify-content: center;\n            font-family: 'Courier New', monospace;\n            backdrop-filter: blur(5px);\n        `;\n\n        const box = document.createElement('div');\n        box.style.cssText = `\n            padding: 30px 40px; background: #141419;\n            border: 2px solid ${color}; border-radius: 12px;\n            text-align: center; position: relative;\n            max-width: 600px; width: 90%;\n            box-shadow: 0 0 50px ${color}40;\n        `;\n\n        box.innerHTML = `\n            <h1 style=\"color: ${color}; font-size: 42px; margin: 0 0 10px 0; letter-spacing: 6px; text-shadow: 0 0 20px ${color}60;\">${msg}</h1>\n            <p style=\"color: #888; font-size: 12px; margin-bottom: 20px;\">${won ? 'Has dominado el mapa' : 'Tus fuerzas han cado'}</p>\n            \n            ${graphUI}\n            ${statsHTML}\n            \n            <button onclick=\"location.reload()\" style=\"\n                margin-top: 20px; padding: 12px 30px;\n                background: ${color}; border: none; border-radius: 4px;\n                color: white; font-family: 'Courier New', monospace;\n                font-size: 14px; cursor: pointer; letter-spacing: 2px;\n                transition: all 0.2s; box-shadow: 0 0 15px ${color}40;\">\n                JUGAR DE NUEVO\n            </button>\n        `;\n\n        overlay.appendChild(box);\n        document.body.appendChild(overlay);\n\n        // Define graph update function globally so buttons can call it\n        window.updateGraph = (type) => {\n            const canvas = document.getElementById('stats-graph-sp');\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            const w = canvas.width;\n            const h = canvas.height;\n\n            ctx.clearRect(0, 0, w, h);\n\n            let dataArray = [];\n            let title = '';\n            let timeScale = 1; // Divide time by this to get minutes\n\n            // Update active button style\n            ['prod', 'units', 'nodes'].forEach(t => {\n                const btn = document.getElementById(`btn-graph-${t}`);\n                if (btn) btn.style.borderColor = t === type ? color : '#444';\n                if (btn) btn.style.color = t === type ? color : '#888';\n            });\n\n            if (type === 'production') {\n                dataArray = stats.productionHistory || [];\n                title = 'PRODUCCIN (Unidades/Min)';\n                timeScale = 1; // Already in minutes\n            } else if (type === 'units') {\n                dataArray = stats.history || [];\n                title = 'EJRCITO TOTAL';\n                timeScale = 60; // Seconds to minutes\n            } else if (type === 'nodes') {\n                dataArray = stats.nodeHistory || [];\n                title = 'TERRITORIO (Nodos)';\n                timeScale = 60; // Seconds to minutes\n            }\n\n            if (!dataArray || dataArray.length === 0) {\n                ctx.fillStyle = '#444';\n                ctx.textAlign = 'center';\n                ctx.fillText('No hay datos disponibles', w / 2, h / 2);\n                return;\n            }\n\n            // Find max value\n            let maxVal = 0;\n            dataArray.forEach(p => {\n                const val = p.rate !== undefined ? p.rate : p.count;\n                if (val > maxVal) maxVal = val;\n            });\n            maxVal = Math.ceil(Math.max(maxVal, 5) * 1.1); // Min 5, 10% padding\n\n            // Draw Grid\n            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            for (let i = 0; i <= 4; i++) {\n                const y = h - (i / 4) * h * 0.9 - 5;\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n                ctx.font = '10px monospace';\n                ctx.fillText(Math.round((i / 4) * maxVal), 5, y - 2);\n            }\n            ctx.stroke();\n\n            // Group by player\n            const playerData = {};\n            dataArray.forEach(p => {\n                if (!playerData[p.playerId]) playerData[p.playerId] = [];\n                playerData[p.playerId].push(p);\n            });\n\n            // Draw Lines\n            for (let pid in playerData) {\n                const data = playerData[pid];\n                data.sort((a, b) => a.time - b.time);\n\n                const pC = playerColors[parseInt(pid) % playerColors.length];\n                ctx.strokeStyle = pC;\n                ctx.lineWidth = 2;\n                ctx.lineJoin = 'round';\n                ctx.beginPath();\n\n                data.forEach((p, i) => {\n                    const val = p.rate !== undefined ? p.rate : p.count;\n                    const t = (p.time / timeScale);\n                    const x = (t / (stats.elapsed || 1)) * w;\n                    const y = h - (val / maxVal) * h * 0.9 - 5;\n\n                    if (i === 0) ctx.moveTo(x, y);\n                    else ctx.lineTo(x, y);\n                });\n                ctx.stroke();\n\n                // Dots (optional, maybe too many?)\n                // Only draw dots if few points\n                if (data.length < 50) {\n                    ctx.fillStyle = pC;\n                    data.forEach(p => {\n                        const val = p.rate !== undefined ? p.rate : p.count;\n                        const t = (p.time / timeScale);\n                        const x = (t / (stats.elapsed || 1)) * w;\n                        const y = h - (val / maxVal) * h * 0.9 - 5;\n                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();\n                    });\n                }\n            }\n\n            // Title\n            ctx.fillStyle = '#888';\n            ctx.font = '12px monospace';\n            ctx.textAlign = 'center';\n            ctx.fillText(title, w / 2, 15);\n        };\n\n        window.downloadGraph = () => {\n            const canvas = document.getElementById('stats-graph-sp');\n            if (canvas) {\n                const link = document.createElement('a');\n                link.download = `nanowar-stats-${Date.now()}.png`;\n                link.href = canvas.toDataURL();\n                link.click();\n            }\n        };\n\n        // Draw initial graph\n        setTimeout(() => {\n            window.updateGraph('production');\n        }, 100);\n    }\n}\n","import { sounds } from './SoundManager.js';\n\nexport class InputManager {\n    constructor(game) {\n        this.game = game;\n        this.canvas = game.canvas;\n        this.mouse = { x: 0, y: 0, down: false, rightDown: false, drag: false };\n        this.mouseDownPos = { x: 0, y: 0 };\n        this.isPanning = false;\n        this.spaceDown = false;\n        this.nodeUnderMouse = null; // Track if mouse is over a node\n        this.setupEvents();\n    }\n\n    setupEvents() {\n        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());\n        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));\n        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));\n        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));\n        this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });\n\n        document.addEventListener('keydown', (e) => this.onKeyDown(e));\n        document.addEventListener('keyup', (e) => this.onKeyUp(e));\n    }\n\n    onMouseDown(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        this.mouse.x = e.clientX - rect.left;\n        this.mouse.y = e.clientY - rect.top;\n        this.mouseDownPos = { x: this.mouse.x, y: this.mouse.y };\n\n        if (this.spaceDown || e.button === 1) {\n            this.isPanning = true;\n            return;\n        }\n\n        // Check if mouse is over a node\n        const worldPos = this.game.camera.screenToWorld(this.mouse.x, this.mouse.y);\n        this.nodeUnderMouse = this.game.state.nodes.find(n => {\n            const dx = n.x - worldPos.x, dy = n.y - worldPos.y;\n            return Math.sqrt(dx * dx + dy * dy) < n.radius + 10;\n        }) || null;\n\n        if (e.button === 0) this.mouse.down = true;\n        if (e.button === 2) this.mouse.rightDown = true;\n\n        this.game.systems.selection.handleMouseDown(this.mouse, e);\n    }\n\n    onMouseMove(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n\n        if (this.isPanning) {\n            const dx = mx - this.mouse.x;\n            const dy = my - this.mouse.y;\n            this.game.camera.pan(dx, dy);\n        } else if (this.mouse.down || this.mouse.rightDown) {\n            const dx = mx - this.mouseDownPos.x;\n            const dy = my - this.mouseDownPos.y;\n            if (Math.sqrt(dx * dx + dy * dy) > 5) this.mouse.drag = true;\n        }\n\n        this.mouse.x = mx;\n        this.mouse.y = my;\n\n        if (!this.isPanning) {\n            this.game.systems.selection.handleMouseMove(this.mouse, e);\n        }\n    }\n\n    onMouseUp(e) {\n        this.isPanning = false;\n        if (e.button === 0) this.mouse.down = false;\n        if (e.button === 2) this.mouse.rightDown = false;\n\n        this.game.systems.selection.handleMouseUp(this.mouse, e);\n        this.mouse.drag = false;\n    }\n\n    onWheel(e) {\n        e.preventDefault();\n        const delta = e.deltaY > 0 ? 0.8 : 1.2; // Increase speed slightly\n        this.game.camera.zoomAt(this.mouse.x, this.mouse.y, delta);\n    }\n\n    onKeyDown(e) {\n        if (e.code === 'Space') {\n            this.spaceDown = true;\n            e.preventDefault();\n        }\n        if (e.code === 'KeyT') {\n            this.game.systems.selection.rallyMode = true;\n        }\n        if (e.code === 'KeyS') {\n            const sel = this.game.systems.selection;\n            if (this.game.controller && this.game.controller.sendAction) {\n                this.game.controller.sendAction({\n                    type: 'stop',\n                    unitIds: Array.from(sel.selectedEntities)\n                });\n            } else {\n                sel.selectedEntities.forEach(id => {\n                    const ent = this.game.state.entities.find(e => e.id === id);\n                    if (ent) ent.stop();\n                });\n            }\n        }\n    }\n\n    onKeyUp(e) {\n        if (e.code === 'Space') {\n            this.spaceDown = false;\n        }\n    }\n\n    update(dt) {\n    }\n}\n","import { sounds } from './SoundManager.js';\n\nexport class SelectionManager {\n    constructor(game) {\n        this.game = game;\n        this.selectedNodes = new Set();\n        this.selectedEntities = new Set();\n        this.isSelectingBox = false;\n        this.boxStart = { x: 0, y: 0 };\n        this.currentPath = [];\n        this.rallyMode = false;\n    }\n\n    isSelected(obj) {\n        if (obj.radius > 10) {\n            return this.selectedNodes.has(obj.id);\n        }\n        return this.selectedEntities.has(obj.id);\n    }\n\n    handleMouseDown(mouse, event) {\n        const worldPos = this.game.camera.screenToWorld(mouse.x, mouse.y);\n\n        if (event.button === 0) { // Left Click\n            const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n            if (this.rallyMode && this.selectedNodes.size > 0) {\n                const targetNode = this.game.state.nodes.find(n => {\n                    const dx = n.x - worldPos.x, dy = n.y - worldPos.y;\n                    return Math.sqrt(dx * dx + dy * dy) < n.radius + 10;\n                });\n\n                if (this.game.controller.sendAction) {\n                    this.game.controller.sendAction({\n                        type: 'rally',\n                        nodeIds: Array.from(this.selectedNodes),\n                        targetX: worldPos.x,\n                        targetY: worldPos.y,\n                        targetNodeId: targetNode ? targetNode.id : null\n                    });\n                } else {\n                    this.selectedNodes.forEach(id => {\n                        const node = this.game.state.nodes.find(n => n.id === id);\n                        if (node && node.owner === playerIndex) node.setRallyPoint(worldPos.x, worldPos.y, targetNode);\n                    });\n                }\n                this.rallyMode = false;\n                return;\n            }\n\n            if (!event.shiftKey) {\n                this.clear();\n            }\n            this.boxStart = { x: mouse.x, y: mouse.y };\n\n            if (event.detail === 2) { // Double click\n                this.handleDoubleClick(mouse.x, mouse.y);\n                return;\n            }\n        }\n\n        if (event.button === 2) { // Right Click\n            this.currentPath = [worldPos];\n            this.handleRightClick(worldPos.x, worldPos.y);\n        }\n    }\n\n    handleDoubleClick(mx, my) {\n        const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n        const clickedNode = this.game.state.nodes.find(n => n.isPointInside(mx, my, this.game.camera));\n        if (clickedNode) {\n            // Select all nodes of the same owner\n            this.game.state.nodes.filter(n => n.owner === clickedNode.owner).forEach(n => {\n                this.selectedNodes.add(n.id);\n                // Also select units around them if owner is player\n                if (n.owner === playerIndex) {\n                    this.game.state.entities.forEach(e => {\n                        if (e.owner === playerIndex && !e.dead && !e.dying) {\n                            const dx = e.x - n.x, dy = e.y - n.y;\n                            if (Math.sqrt(dx * dx + dy * dy) <= n.influenceRadius) {\n                                this.selectedEntities.add(e.id);\n                            }\n                        }\n                    });\n                }\n            });\n            return;\n        }\n        const clickedEntity = this.game.state.entities.find(e => !e.dead && !e.dying && e.isPointInside(mx, my, this.game.camera));\n        if (clickedEntity) {\n            const cam = this.game.camera;\n\n            this.game.state.entities.forEach(e => {\n                if (!e.dead && !e.dying && e.owner === clickedEntity.owner) {\n                    // Only select if within the current screen view\n                    const screen = cam.worldToScreen(e.x, e.y);\n                    if (screen.x >= 0 && screen.x <= window.innerWidth && screen.y >= 0 && screen.y <= window.innerHeight) {\n                        this.selectedEntities.add(e.id);\n                    }\n                }\n            });\n        }\n    }\n\n    handleMouseMove(mouse, event) {\n        if (mouse.down && mouse.drag) {\n            this.isSelectingBox = true;\n        }\n        if (mouse.rightDown) {\n            const worldPos = this.game.camera.screenToWorld(mouse.x, mouse.y);\n            // Only add if different enough from last point (30 pixels)\n            const lastPoint = this.currentPath[this.currentPath.length - 1];\n            const dx = worldPos.x - lastPoint.x;\n            const dy = worldPos.y - lastPoint.y;\n\n            if (Math.sqrt(dx * dx + dy * dy) > 30) {\n                this.currentPath.push(worldPos);\n\n                // In singleplayer, apply locally. In multiplayer, we might need a specific action.\n                // For now, waypoint painting is locally predicted but authoritative on server.\n                if (!this.game.controller.sendAction) {\n                    this.selectedEntities.forEach(id => {\n                        const ent = this.game.state.entities.find(e => e.id === id);\n                        if (ent && !ent.dead) {\n                            ent.addWaypoint(worldPos.x, worldPos.y);\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n\n    selectAt(mx, my) {\n        const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n        const clickedNode = this.game.state.nodes.find(n => n.isPointInside(mx, my, this.game.camera));\n        if (clickedNode) {\n            this.selectedNodes.add(clickedNode.id);\n            // Also select units in its area if owned by player\n            if (clickedNode.owner === playerIndex) {\n                this.game.state.entities.forEach(e => {\n                    if (e.owner === playerIndex && !e.dead && !e.dying) {\n                        const dx = e.x - clickedNode.x, dy = e.y - clickedNode.y;\n                        if (Math.sqrt(dx * dx + dy * dy) <= clickedNode.influenceRadius) {\n                            this.selectedEntities.add(e.id);\n                        }\n                    }\n                });\n            }\n            return;\n        }\n\n        const clickedEntity = this.game.state.entities.find(e => !e.dead && !e.dying && e.isPointInside(mx, my, this.game.camera));\n        if (clickedEntity) {\n            this.selectedEntities.add(clickedEntity.id);\n            return;\n        }\n    }\n\n    selectInBox(x1, y1, x2, y2) {\n        const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n        this.game.state.entities.forEach(e => {\n            if (e.owner === playerIndex && !e.dead && e.isInsideRect(x1, y1, x2, y2, this.game.camera)) {\n                this.selectedEntities.add(e.id);\n            }\n        });\n        this.game.state.nodes.forEach(n => {\n            if (n.owner === playerIndex && n.isInsideRect(x1, y1, x2, y2, this.game.camera)) {\n                this.selectedNodes.add(n.id);\n                // Also select units around it\n                this.game.state.entities.forEach(e => {\n                    if (e.owner === playerIndex && !e.dead && !e.dying) {\n                        const dx = e.x - n.x, dy = e.y - n.y;\n                        if (Math.sqrt(dx * dx + dy * dy) <= n.influenceRadius) {\n                            this.selectedEntities.add(e.id);\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    handleRightClick(worldX, worldY) {\n        const targetNode = this.game.state.nodes.find(n => {\n            const dx = n.x - worldX, dy = n.y - worldY;\n            return Math.sqrt(dx * dx + dy * dy) < n.radius;\n        });\n\n        if (this.selectedEntities.size > 0) {\n            this.executeCommand(worldX, worldY, targetNode);\n        }\n    }\n\n    handleMouseUp(mouse, event) {\n        if (event.button === 0) {\n            // Check if this was a drag from a selected node to set rally point\n            if (mouse.drag && this.selectedNodes.size > 0) {\n                // Check if ended on a node (or anywhere - allow setting rally anywhere)\n                const worldPos = this.game.camera.screenToWorld(mouse.x, mouse.y);\n                const targetNode = this.game.state.nodes.find(n => {\n                    const dx = n.x - worldPos.x, dy = n.y - worldPos.y;\n                    return Math.sqrt(dx * dx + dy * dy) < n.radius + 15;\n                });\n                \n                const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n                \n                // Check if we dragged far enough to be intentional\n                const dragDist = Math.sqrt(\n                    Math.pow(mouse.x - this.game.systems.input.mouseDownPos.x, 2) +\n                    Math.pow(mouse.y - this.game.systems.input.mouseDownPos.y, 2)\n                );\n                \n                if (dragDist > 20) { // Must drag at least 20 pixels\n                    if (this.game.controller.sendAction) {\n                        this.game.controller.sendAction({\n                            type: 'rally',\n                            nodeIds: Array.from(this.selectedNodes),\n                            targetX: worldPos.x,\n                            targetY: worldPos.y,\n                            targetNodeId: targetNode ? targetNode.id : null\n                        });\n                    } else {\n                        this.selectedNodes.forEach(id => {\n                            const node = this.game.state.nodes.find(n => n.id === id);\n                            if (node && node.owner === playerIndex) node.setRallyPoint(worldPos.x, worldPos.y, targetNode);\n                        });\n                    }\n                    this.game.systems.input.nodeUnderMouse = null;\n                    this.isSelectingBox = false;\n                    return;\n                }\n            }\n\n            if (this.isSelectingBox) {\n                this.selectInBox(\n                    this.game.systems.input.mouseDownPos.x,\n                    this.game.systems.input.mouseDownPos.y,\n                    mouse.x,\n                    mouse.y\n                );\n                this.isSelectingBox = false;\n            } else {\n                this.selectAt(mouse.x, mouse.y);\n            }\n            // Play selection sound\n            if (this.selectedEntities.size > 0 || this.selectedNodes.size > 0) {\n                sounds.playSelect();\n            }\n        }\n        if (event.button === 2) {\n            if (this.currentPath.length > 2 && this.selectedEntities.size > 0) {\n                const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n                // Add a visual waypoint line to the game\n                this.game.spawnWaypointLine([...this.currentPath], playerIndex);\n\n                if (this.game.controller.sendAction) {\n                    this.game.controller.sendAction({\n                        type: 'path',\n                        unitIds: Array.from(this.selectedEntities),\n                        path: this.currentPath\n                    });\n                }\n                sounds.playMove();\n            }\n            this.currentPath = [];\n        }\n        // Clear node under mouse after mouse up\n        this.game.systems.input.nodeUnderMouse = null;\n    }\n\n    applyPathToSelection() {\n        this.selectedEntities.forEach(id => {\n            const ent = this.game.state.entities.find(e => e.id === id);\n            if (ent && !ent.dead) {\n                ent.waypoints = [...this.currentPath];\n                ent.currentTarget = null;\n            }\n        });\n    }\n\n    executeCommand(worldX, worldY, targetNode) {\n        this.game.spawnCommandIndicator(worldX, worldY, targetNode ? 'attack' : 'move');\n        \n        // Play sound\n        if (targetNode && targetNode.owner !== -1 && targetNode.owner !== (this.game.controller.playerIndex || 0)) {\n            sounds.playAttack();\n        } else {\n            sounds.playMove();\n        }\n\n        if (this.game.controller.sendAction) {\n            // Multiplayer execution via server\n            this.game.controller.sendAction({\n                type: 'move',\n                sourceNodeId: null, // Logic on server handles this if needed or uses IDs directly\n                targetNodeId: targetNode ? targetNode.id : null,\n                targetX: worldX,\n                targetY: worldY,\n                unitIds: Array.from(this.selectedEntities)\n            });\n        } else {\n            // Singleplayer local execution\n            this.selectedEntities.forEach(id => {\n                const ent = this.game.state.entities.find(e => e.id === id);\n                if (ent && !ent.dead) {\n                    ent.setTarget(worldX, worldY, targetNode);\n                }\n            });\n        }\n    }\n\n    clear() {\n        this.selectedNodes.clear();\n        this.selectedEntities.clear();\n        this.rallyMode = false;\n    }\n}\n","// Simple Sound Manager using Web Audio API\n// No external files needed - generates sounds programmatically\n\nexport class SoundManager {\n    constructor() {\n        this.ctx = null;\n        this.enabled = true;\n        this.playerIndex = 0; // Default to player 0\n        this.init();\n    }\n\n    init() {\n        try {\n            this.ctx = new (window.AudioContext || window.webkitAudioContext)();\n        } catch (e) {\n            console.warn('Web Audio API not supported');\n        }\n    }\n\n    setPlayerIndex(idx) {\n        this.playerIndex = idx;\n    }\n\n    resume() {\n        if (this.ctx && this.ctx.state === 'suspended') {\n            this.ctx.resume();\n        }\n    }\n\n    playTone(freq, duration, type = 'sine', volume = 0.1) {\n        if (!this.ctx || !this.enabled) return;\n        \n        this.resume();\n        \n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        \n        osc.type = type;\n        osc.frequency.value = freq;\n        \n        gain.gain.setValueAtTime(volume, this.ctx.currentTime);\n        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);\n        \n        osc.connect(gain);\n        gain.connect(this.ctx.destination);\n        \n        osc.start();\n        osc.stop(this.ctx.currentTime + duration);\n    }\n\n    playSelect() {\n        this.playTone(700, 0.05, 'triangle', 0.06);\n    }\n\n    playMove() {\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        // Quick double blip - rhythmic\n        [400, 500].forEach((freq, i) => {\n            const osc = this.ctx.createOscillator();\n            const gain = this.ctx.createGain();\n            \n            osc.type = 'triangle';\n            osc.frequency.value = freq;\n            \n            const startTime = this.ctx.currentTime + i * 0.05;\n            \n            gain.gain.setValueAtTime(0.08, startTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.06);\n            \n            osc.connect(gain);\n            gain.connect(this.ctx.destination);\n            \n            osc.start(startTime);\n            osc.stop(startTime + 0.06);\n        });\n    }\n\n    playAttack() {\n        // Harsh descending sound\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        \n        osc.type = 'square';\n        osc.frequency.setValueAtTime(400, this.ctx.currentTime);\n        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);\n        \n        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);\n        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);\n        \n        osc.connect(gain);\n        gain.connect(this.ctx.destination);\n        \n        osc.start();\n        osc.stop(this.ctx.currentTime + 0.15);\n    }\n\n    playCapture() {\n        // Simple satisfying \"ding\" - not too loud\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        // Single clear tone\n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        \n        osc.type = 'sine';\n        osc.frequency.value = 880;\n        \n        gain.gain.setValueAtTime(0, this.ctx.currentTime);\n        gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);\n        \n        osc.connect(gain);\n        gain.connect(this.ctx.destination);\n        \n        osc.start();\n        osc.stop(this.ctx.currentTime + 0.25);\n    }\n\n    playNodeHealing(percent) {\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        // Frequency increases with percent: 200Hz at 0%, 900Hz at 100%\n        const freq = 200 + percent * 700;\n        \n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        \n        osc.type = 'sine';\n        osc.frequency.value = freq;\n        \n        // Satisfying envelope\n        gain.gain.setValueAtTime(0, this.ctx.currentTime);\n        gain.gain.linearRampToValueAtTime(0.06, this.ctx.currentTime + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);\n        \n        osc.connect(gain);\n        gain.connect(this.ctx.destination);\n        \n        osc.start();\n        osc.stop(this.ctx.currentTime + 0.12);\n    }\n\n    playCollision() {\n        // Short satisfying \"pop\" for cell collisions - own cells only\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        \n        osc.type = 'sine';\n        // Quick frequency sweep for \"pop\" effect\n        osc.frequency.setValueAtTime(200, this.ctx.currentTime);\n        osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.08);\n        \n        gain.gain.setValueAtTime(0.06, this.ctx.currentTime);\n        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);\n        \n        osc.connect(gain);\n        gain.connect(this.ctx.destination);\n        \n        osc.start();\n        osc.stop(this.ctx.currentTime + 0.08);\n    }\n\n    playSpawn() {\n        // Quick blip\n        this.playTone(600, 0.05, 'sine', 0.04);\n    }\n\n    playWin() {\n        // Victory fanfare\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        const notes = [523, 659, 784, 1047];\n        notes.forEach((freq, i) => {\n            const osc = this.ctx.createOscillator();\n            const gain = this.ctx.createGain();\n            \n            osc.type = 'square';\n            osc.frequency.value = freq;\n            \n            const startTime = this.ctx.currentTime + i * 0.15;\n            gain.gain.setValueAtTime(0.1, startTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);\n            \n            osc.connect(gain);\n            gain.connect(this.ctx.destination);\n            \n            osc.start(startTime);\n            osc.stop(startTime + 0.3);\n        });\n    }\n\n    playLose() {\n        // Sad descending\n        if (!this.ctx || !this.enabled) return;\n        this.resume();\n        \n        const notes = [400, 350, 300, 250];\n        notes.forEach((freq, i) => {\n            const osc = this.ctx.createOscillator();\n            const gain = this.ctx.createGain();\n            \n            osc.type = 'sawtooth';\n            osc.frequency.value = freq;\n            \n            const startTime = this.ctx.currentTime + i * 0.2;\n            gain.gain.setValueAtTime(0.08, startTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);\n            \n            osc.connect(gain);\n            gain.connect(this.ctx.destination);\n            \n            osc.start(startTime);\n            osc.stop(startTime + 0.4);\n        });\n    }\n\n    toggle() {\n        this.enabled = !this.enabled;\n        return this.enabled;\n    }\n}\n\n// Global instance\nexport const sounds = new SoundManager();\n","export class UIManager {\n    constructor(game) {\n        this.game = game;\n        this.lastProductionUpdate = 0;\n    }\n\n    draw(renderer) {\n        const ctx = renderer.ctx;\n        const h = this.game.canvas.height;\n        const w = this.game.canvas.width;\n\n        const playerIndex = this.game.controller.playerIndex !== undefined ? this.game.controller.playerIndex : 0;\n\n        // --- PLAYER INFO (Bottom Left) ---\n        const playerColor = [\n            '#4CAF50', '#f44336', '#2196F3', '#FF9800',\n            '#9C27B0', '#00BCD4', '#FFEB3B', '#E91E63'\n        ][playerIndex % 8];\n\n        ctx.fillStyle = playerColor;\n        ctx.font = 'bold 16px monospace';\n        ctx.textAlign = 'left';\n        ctx.fillText(`ERES JUGADOR ${playerIndex + 1}`, 20, h - 40);\n\n        // Game timer\n        const elapsed = this.game.state.elapsedTime || 0;\n        const minutes = Math.floor(elapsed / 60);\n        const seconds = Math.floor(elapsed % 60);\n        ctx.fillStyle = '#fff';\n        ctx.font = '14px monospace';\n        ctx.fillText(`TIEMPO: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, h - 20);\n\n        // --- SELECTION INFO (Top Right - Below DOM Header) ---\n        const selectionCount = this.game.systems.selection.selectedEntities.size;\n\n        // Background for selection (shifted down to avoid top bar buttons)\n        const selBoxY = 70;\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        ctx.fillRect(w - 220, selBoxY, 210, 40);\n        ctx.strokeStyle = playerColor;\n        ctx.strokeRect(w - 220, selBoxY, 210, 40);\n\n        ctx.fillStyle = '#fff';\n        ctx.font = 'bold 14px monospace';\n        ctx.textAlign = 'right';\n        ctx.fillText(`SELECCIONADOS: ${selectionCount}`, w - 20, selBoxY + 25);\n\n\n        // --- STATS PANEL (Bottom Right) ---\n        // Combine Production Rates and Unit Counts\n        const showProduction = this.game.state.showProduction;\n        const playerCount = this.game.state.playerCount;\n\n        // Calculate height based on players\n        // Header (30) + Player Rows (24 * count) - Increased spacing\n        const panelHeight = 45 + (playerCount * 24);\n        const panelWidth = 280; // Wider for larger text\n        const panelX = w - panelWidth - 20;\n        const panelY = h - panelHeight - 20; // More padding from bottom\n\n        // Background\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Darker\n        ctx.fillRect(panelX, panelY, panelWidth, panelHeight);\n        ctx.strokeStyle = '#555';\n        ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);\n\n        // Header\n        ctx.fillStyle = '#bbb';\n        ctx.font = 'bold 13px monospace'; // Larger header\n        ctx.textAlign = 'left';\n        ctx.fillText('ESTADSTICAS (PROD/MIN | TOT)', panelX + 15, panelY + 25);\n\n        // Separator\n        ctx.beginPath();\n        ctx.moveTo(panelX + 10, panelY + 35);\n        ctx.lineTo(panelX + panelWidth - 10, panelY + 35);\n        ctx.strokeStyle = '#777';\n        ctx.stroke();\n\n        const colors = ['#4CAF50', '#f44336', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4', '#FFEB3B', '#E91E63'];\n\n        ctx.font = 'bold 14px monospace'; // Larger body font\n        for (let i = 0; i < playerCount; i++) {\n            const isMe = i === playerIndex;\n            const pColor = colors[i % colors.length];\n\n            // Production Rate\n            const rawRate = this.game.state.productionRates?.[i] || 0;\n            const ratePerMin = Math.round(rawRate * 60);\n\n            // Total Produced\n            const stats = this.game.state.stats;\n            const produced = stats?.unitsProduced?.[i]?.total || (typeof stats?.unitsProduced?.[i] === 'number' ? stats.unitsProduced[i] : 0);\n\n            // Current Units (Active)\n            const current = stats?.unitsCurrent?.[i] || 0;\n\n            ctx.fillStyle = pColor;\n            const label = isMe ? 'T' : `P${i + 1}`;\n\n            // Format: \"P1: 120/m | 500 (200)\"\n            // Rate | Total (Active)\n            const text = `${label}: ${ratePerMin}/m | ${produced} (${current})`;\n\n            ctx.fillText(text, panelX + 15, panelY + 58 + (i * 24));\n        }\n\n        // --- RALLY MODE ---\n        if (this.game.systems.selection.selectedNodes.size > 0) {\n            ctx.fillStyle = '#ff0';\n            ctx.font = 'bold 14px monospace';\n            ctx.textAlign = 'center';\n            ctx.fillText('MODO RALLY: T para punto de spawn', w / 2, h - 50);\n        }\n    }\n}\n","export function hexToRgba(hex, alpha) {\n    const r = parseInt(hex.slice(1, 3), 16);\n    const g = parseInt(hex.slice(3, 5), 16);\n    const b = parseInt(hex.slice(5, 7), 16);\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\nexport function drawCircle(ctx, x, y, radius, color) {\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n}\n","export class AIController {\n    constructor(game, playerId, difficulty = 'Normal') {\n        this.game = game;\n        this.playerId = playerId;\n        this.timer = 0;\n        this.difficulty = difficulty;\n\n        // Personalities: Aggressive, Defensive, Expansive\n        const personalities = ['aggressive', 'defensive', 'expansive'];\n        if (this.difficulty === 'Easy') {\n            // Easy mode always gets defensive personality - less aggressive\n            this.personality = 'defensive';\n        } else {\n            this.personality = personalities[Math.floor(Math.random() * personalities.length)];\n        }\n\n        // Set interval based on difficulty - Easy is VERY slow\n        const baseIntervals = {\n            'Easy': 5.0,\n            'Normal': 1.2,\n            'Hard': 0.8,\n            'Nightmare': 0.4\n        };\n        this.decisionInterval = baseIntervals[this.difficulty] + (Math.random() * 0.5);\n\n        console.log(`[AI INFO] Player ${playerId} initialized: Difficulty=${this.difficulty}, Personality=${this.personality}`);\n    }\n\n    update(dt) {\n        this.timer += dt;\n        if (this.timer >= this.decisionInterval) {\n            this.timer = 0;\n            this.makeDecision();\n        }\n    }\n\n    makeDecision() {\n        const myNodes = this.game.state.nodes.filter(n => n.owner === this.playerId);\n        const allNodes = this.game.state.nodes;\n        const enemyNodes = allNodes.filter(n => n.owner !== this.playerId && n.owner !== -1);\n        const neutralNodes = allNodes.filter(n => n.owner === -1);\n\n        if (myNodes.length === 0) return;\n\n        myNodes.forEach(sourceNode => {\n            const defenderCount = sourceNode.areaDefenders ? sourceNode.areaDefenders.length : 0;\n\n            // Attack sensitivity based on difficulty and personality\n            let minDefendersToStay = 5;\n            if (this.difficulty === 'Nightmare') minDefendersToStay = 2;\n            if (this.difficulty === 'Hard') minDefendersToStay = 4;\n            if (this.difficulty === 'Easy') minDefendersToStay = 18; // Keeps almost all units defending!\n\n            if (this.personality === 'defensive') minDefendersToStay += 5;\n            if (this.personality === 'aggressive') minDefendersToStay -= 2;\n\n            // For Easy: prioritize neutrals over attacking\n            if (this.difficulty === 'Easy' && neutralNodes.length > 0) {\n                // Easy AI focuses on expansion, rarely attacks\n                minDefendersToStay = 30; // Super defensive!\n            }\n\n            // Heal check for Defensive\n            if (this.personality === 'defensive' && sourceNode.hp < sourceNode.maxHp * 0.9) {\n                return; // Prioritize healing\n            }\n\n            if (defenderCount > minDefendersToStay || (defenderCount > 2 && Math.random() < 0.15)) {\n                let bestTarget = null;\n                let bestScore = -Infinity;\n\n                allNodes.filter(n => n !== sourceNode).forEach(target => {\n                    const dx = target.x - sourceNode.x;\n                    const dy = target.y - sourceNode.y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n\n                    // Score calculation: higher is better\n                    let score = 1000 / dist; // Base proximity score\n\n                    // Ownership modifiers\n                    if (target.owner === -1) {\n                        // Neutral node\n                        let expansionWeight = 1.5;\n                        if (this.personality === 'expansive') expansionWeight = 3.0;\n                        if (this.difficulty === 'Easy') expansionWeight = 5.0; // Prioritize neutrals!\n                        // Reduce priority if we already have many nodes\n                        if (myNodes.length > 5) expansionWeight *= 0.5;\n                        score *= expansionWeight;\n                    } else if (target.owner !== this.playerId) {\n                        // Enemy node\n                        let attackWeight = 1.0;\n                        if (this.personality === 'aggressive') attackWeight = 2.5;\n                        if (this.difficulty === 'Nightmare') attackWeight = 3.0;\n                        if (this.difficulty === 'Hard') attackWeight = 2.0;\n                        if (this.difficulty === 'Easy') attackWeight = 0.1; // Almost never attacks enemies!\n                        if (this.difficulty === 'Hard' || this.difficulty === 'Nightmare') {\n                            // Target weak enemy nodes\n                            if (target.hp < target.maxHp * 0.4) attackWeight *= 2.0;\n                        }\n                        score *= attackWeight;\n                    } else {\n                        // Reinforce own node\n                        if (this.personality === 'defensive' && target.hp < target.maxHp * 0.5) {\n                            score *= 2.0;\n                        } else {\n                            score *= 0.1; // Low priority to reinforce healthy nodes\n                        }\n                    }\n\n                    if (score > bestScore) {\n                        bestScore = score;\n                        bestTarget = target;\n                    }\n                });\n\n                if (bestTarget) {\n                    this.sendUnits(sourceNode, bestTarget);\n                }\n            }\n        });\n    }\n\n    sendUnits(sourceNode, targetNode) {\n        const units = this.game.state.entities.filter(e =>\n            e.owner === this.playerId &&\n            !e.dead &&\n            !e.targetNode &&\n            Math.sqrt((e.x - sourceNode.x) ** 2 + (e.y - sourceNode.y) ** 2) <= sourceNode.influenceRadius\n        );\n\n        if (units.length === 0) return;\n\n        // Attack percentage based on personality/difficulty\n        let attackPercent = 0.5;\n        if (this.personality === 'aggressive') attackPercent = 0.8;\n        if (this.difficulty === 'Nightmare') attackPercent = 0.9;\n        if (this.difficulty === 'Hard') attackPercent = 0.65;\n        if (this.difficulty === 'Easy') attackPercent = 0.05; // Only 5% of units attack!\n\n        // Sort units by distance to source node (descending)\n        // This ensures we send the FURTHEST units first, keeping the CLOSEST ones as defenders\n        units.sort((a, b) => {\n            const distSqA = (a.x - sourceNode.x) ** 2 + (a.y - sourceNode.y) ** 2;\n            const distSqB = (b.x - sourceNode.x) ** 2 + (b.y - sourceNode.y) ** 2;\n            return distSqB - distSqA; // Descending order\n        });\n\n        const count = Math.ceil(units.length * Math.min(attackPercent, 0.95));\n        const attackers = units.slice(0, count);\n\n        attackers.forEach(e => {\n            e.setTarget(targetNode.x, targetNode.y, targetNode);\n        });\n    }\n}\n","import { PLAYER_COLORS, GAME_SETTINGS } from './GameConfig.js';\n\nexport class Entity {\n    constructor(x, y, ownerId, id) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n        this.owner = ownerId;\n\n        this.radius = 5;\n        this.vx = 0;\n        this.vy = 0;\n        this.maxSpeed = 50;\n        this.speedBoost = 0; // 0 to 1.0 scalar for territorial acceleration\n        // Acceleration removed as per request\n        this.friction = 0.975;\n\n        this.hp = 1;\n        this.damage = 1;\n        this.attackCooldown = 0;\n        this.selected = false;\n        this.dead = false;\n        this.dying = false;\n        this.deathTime = 0;\n\n        this.waypoints = [];\n        this.currentTarget = null;\n        this.absorbTarget = null;\n        this.targetNode = null;\n\n        this.cohesionRadius = 30;\n        this.cohesionForce = 45; // Reduced for more breathing room\n\n        // Map boundary tracking\n        this.outsideTime = 0;\n        this.outsideWarning = false;\n    }\n\n    addWaypoint(x, y) {\n        this.waypoints.push({ x, y });\n    }\n\n    setTarget(x, y, node = null) {\n        this.waypoints = [{ x, y }];\n        this.currentTarget = null;\n        this.targetNode = node;\n    }\n\n    stop() {\n        this.waypoints = [];\n        this.currentTarget = null;\n        this.vx *= 0.3;\n        this.vy *= 0.3;\n        this.targetNode = null;\n    }\n\n    update(dt, spatialGrid, spatialGridNodes, nodes, camera, game) {\n        if (this.dying) {\n            this.deathTime += dt;\n            if (this.deathTime > 0.4) { this.dead = true; }\n            return;\n        }\n\n        if (this.attackCooldown > 0) this.attackCooldown -= dt;\n\n        this.processWaypoints();\n        // Handle physical collisions with other units and nodes\n        this.handleCollisionsAndCohesion(spatialGrid, nodes, game);\n\n        // Movement Logic Overhaul\n        // 1. Check territory for speed boost\n        // 2. Check node proximity for Strict Absorption (target-only)\n\n        let inFriendlyTerritory = false;\n        const speedMult = (game?.state?.speedMultiplier) || 1;\n\n        // OPTIMIZATION: Use spatial grid to find nearby nodes instead of iterating all\n        // Use a search radius that covers the largest possible influence radius (165px max)\n        const nearbyNodes = spatialGridNodes ? spatialGridNodes.retrieveNodes(this.x, this.y, 200) : nodes;\n\n        if (nearbyNodes) {\n            for (let node of nearbyNodes) {\n                const dx = this.x - node.x;\n                const dy = this.y - node.y;\n                const distSq = dx * dx + dy * dy;\n\n                // Check territory influence\n                if (node.owner === this.owner && node.owner !== -1) {\n                    if (distSq < node.influenceRadius * node.influenceRadius) {\n                        inFriendlyTerritory = true;\n                    }\n                }\n\n                // Check proximity interaction (capture/absorb/attack)\n                const dist = Math.sqrt(distSq);\n                const touchRange = node.radius + this.radius;\n\n                if (dist <= touchRange) {\n                    // Neutral node - Capture\n                    if (node.owner === -1) {\n                        if (!this.dying) {\n                            node.receiveAttack(this.owner, 1, game);\n                            this.die('attack', node, game);\n                        }\n                        return; // Unit consumed\n                    }\n\n                    // Owned node - Strict Absorption Logic\n                    if (node.owner === this.owner && node.owner !== -1) {\n                        // Only absorb if explicit target\n                        if (this.targetNode === node) {\n                            if (node.baseHp < node.maxHp && !this.dying) {\n                                node.baseHp += 1;\n                                this.die('absorbed', node, game);\n                                return; // Unit consumed\n                            }\n                            // Reached target but full health? Stop and clear target to avoid bouncing\n                            this.stop();\n                            this.targetNode = null;\n                        }\n                        // If passing through (no target or different target), doing nothing\n                        continue;\n                    }\n\n                    // Enemy node - Attack\n                    if (node.owner !== this.owner) {\n                        if (!this.dying && this.attackCooldown <= 0) {\n                            const allDefenders = node.allAreaDefenders || [];\n\n                            // Prioritize defending units first\n                            const ownerDefenders = allDefenders.filter(e => e.owner === node.owner && !e.dead && !e.dying);\n                            if (ownerDefenders.length > 0) {\n                                ownerDefenders[0].die('sacrifice', node, game);\n                                this.die('attack', node, game);\n                                return;\n                            }\n\n                            // Then rival attackers\n                            const rivalDefenders = allDefenders.filter(e => e.owner !== this.owner && e.owner !== node.owner && !e.dead && !e.dying);\n                            if (rivalDefenders.length > 0) {\n                                rivalDefenders[0].die('sacrifice', node, game);\n                                this.die('attack', node, game);\n                                return;\n                            }\n\n                            // Finally hit the node\n                            node.receiveAttack(this.owner, 1, game);\n                            this.die('attack', node, game);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Random jitter (minimal)\n        const randomForce = 10;\n        this.vx += (Math.random() - 0.5) * randomForce * dt;\n        this.vy += (Math.random() - 0.5) * randomForce * dt;\n\n        // Move towards target (linear force, no ramp-up)\n        if (this.currentTarget) {\n            const dx = this.currentTarget.x - this.x;\n            const dy = this.currentTarget.y - this.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            if (dist > 5) {\n                // Strong force for responsive movement\n                const moveForce = 800;\n                this.vx += (dx / dist) * moveForce * dt;\n                this.vy += (dy / dist) * moveForce * dt;\n            }\n        }\n\n        this.vx *= this.friction;\n        this.vy *= this.friction;\n\n        // Calculate max speed with gradual \"Acceleration Zone\" effect\n        if (inFriendlyTerritory) {\n            this.speedBoost = Math.min(1.0, this.speedBoost + dt * 2.0); // Ramp up in 0.5s\n        } else {\n            this.speedBoost = Math.max(0.0, this.speedBoost - dt * 1.0); // Decay in 1.0s\n        }\n\n        let currentMaxSpeed = this.maxSpeed * (1 + this.speedBoost * 0.4); // Max 40% boost\n        this.hasSpeedBoost = this.speedBoost > 0.1; // Threshold flag for renderer\n\n        currentMaxSpeed *= speedMult;\n\n        // Cap speed\n        const speedSq = this.vx * this.vx + this.vy * this.vy;\n        const maxSpdSq = currentMaxSpeed * currentMaxSpeed;\n\n        if (speedSq > maxSpdSq) {\n            const speed = Math.sqrt(speedSq);\n            this.vx = (this.vx / speed) * currentMaxSpeed;\n            this.vy = (this.vy / speed) * currentMaxSpeed;\n        }\n\n        // Apply movement\n        this.x += this.vx * dt;\n        this.y += this.vy * dt;\n\n        // Check map boundary - die if outside\n        const worldRadius = GAME_SETTINGS.WORLD_RADIUS || 1800;\n        const centerX = (GAME_SETTINGS.WORLD_WIDTH || 2400) / 2;\n        const centerY = (GAME_SETTINGS.WORLD_HEIGHT || 1800) / 2;\n        const dx = this.x - centerX;\n        const dy = this.y - centerY;\n        const distFromCenter = Math.sqrt(dx * dx + dy * dy);\n\n        if (distFromCenter > worldRadius) {\n            this.outsideTime += dt;\n            this.outsideWarning = true;\n            if (this.outsideTime >= (GAME_SETTINGS.OUTSIDE_DEATH_TIME || 5)) {\n                this.die('outOfBounds', null, game);\n                return;\n            }\n        } else {\n            this.outsideTime = 0;\n            this.outsideWarning = false;\n        }\n    }\n\n    processWaypoints() {\n        if (!this.currentTarget && this.waypoints.length > 0) {\n            this.currentTarget = this.waypoints.shift();\n        }\n\n        if (this.currentTarget) {\n            const dx = this.currentTarget.x - this.x;\n            const dy = this.currentTarget.y - this.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            if (dist < 15) {\n                if (this.waypoints.length > 0) {\n                    this.currentTarget = this.waypoints.shift();\n                } else {\n                    this.currentTarget = null;\n                }\n            }\n        }\n    }\n\n    handleCollisionsAndCohesion(spatialGrid, nodes, game) {\n        // Push entities out of nodes physical radius\n        if (nodes) {\n            for (let node of nodes) {\n                const dx = this.x - node.x;\n                const dy = this.y - node.y;\n                const distSq = dx * dx + dy * dy;\n                const minDist = node.radius + this.radius;\n\n                if (distSq < minDist * minDist && distSq > 0) {\n                    const dist = Math.sqrt(distSq);\n                    const overlap = minDist - dist;\n                    const nx = dx / dist;\n                    const ny = dy / dist;\n                    this.x += nx * overlap;\n                    this.y += ny * overlap;\n                    this.vx += nx * 50 * 0.016;\n                    this.vy += ny * 50 * 0.016;\n                }\n            }\n        }\n\n        let cohesionX = 0, cohesionY = 0, cohesionCount = 0;\n        // Optimized spatial query\n        const searchRadius = this.cohesionRadius;\n        const neighbors = spatialGrid.retrieve(this.x, this.y, searchRadius);\n\n        // Check if in flock for stronger cohesion\n        const inFlock = !!this.flockId;\n\n        for (let other of neighbors) {\n            if (other === this || other.dead || other.dying) continue;\n\n            const dx = other.x - this.x;\n            const dy = other.y - this.y;\n            const distSq = dx * dx + dy * dy;\n\n            if (distSq > searchRadius * searchRadius) continue;\n            const dist = Math.sqrt(distSq);\n\n            // COHESION logic - relaxed to prevent over-stacking\n            if (other.owner === this.owner && dist > this.radius * 2.2) {\n                if (inFlock && other.flockId === this.flockId) {\n                    // Flock: slightly stronger cohesion (1.8x) but less than before\n                    cohesionX += (dx / dist) * 1.8;\n                    cohesionY += (dy / dist) * 1.8;\n                    cohesionCount++;\n                } else {\n                    // Normal cohesion\n                    cohesionX += dx / dist;\n                    cohesionY += dy / dist;\n                    cohesionCount++;\n                }\n            }\n\n            // COLLISION logic - intensified to prevent overlapping\n            const minDist = this.radius + other.radius;\n            if (dist < minDist && dist > 0) {\n                const overlap = minDist - dist;\n                const nx = dx / dist;\n                const ny = dy / dist;\n\n                // Push apart more aggressively (0.6 instead of 0.3)\n                this.x -= nx * overlap * 0.6;\n                this.y -= ny * overlap * 0.6;\n\n                if (this.owner !== other.owner) {\n                    this.die('explosion', null, game);\n                    other.die('explosion', null, game);\n                    return;\n                }\n\n                const dvx = other.vx - this.vx;\n                const dvy = other.vy - this.vy;\n                const velAlongNormal = dvx * nx + dvy * ny;\n\n                if (velAlongNormal > 0) {\n                    const j = -(1.3) * velAlongNormal * 0.5;\n                    this.vx -= j * nx;\n                    this.vy -= j * ny;\n                    other.vx += j * nx;\n                    other.vy += j * ny;\n                }\n            }\n        }\n\n        if (cohesionCount > 0) {\n            cohesionX /= cohesionCount;\n            cohesionY /= cohesionCount;\n            this.vx += cohesionX * this.cohesionForce * 0.016;\n            this.vy += cohesionY * this.cohesionForce * 0.016;\n        }\n\n        if (this.currentTarget) this.avoidObstacles(nodes);\n    }\n\n    avoidObstacles(nodes) {\n        const targetDx = this.currentTarget.x - this.x;\n        const targetDy = this.currentTarget.y - this.y;\n        const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);\n        const targetNx = targetDx / targetDist;\n        const targetNy = targetDy / targetDist;\n\n        for (let node of nodes) {\n            if (this.targetNode === node) continue;\n            const dx = node.x - this.x;\n            const dy = node.y - this.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            if (dist < node.radius + 60 && dist > 10) {\n                const dot = (dx / dist) * targetNx + (dy / dist) * targetNy;\n                if (dot > 0.5) {\n                    const perpX = -targetNy;\n                    const perpY = targetNx;\n                    const side = (dx * targetNy - dy * targetNx) > 0 ? 1 : -1;\n                    this.vx += perpX * side * 150 * 0.016;\n                    this.vy += perpY * side * 150 * 0.016; // Stronger avoidance\n                }\n            }\n        }\n    }\n\n    // checkNodeProximity removed as logic is merged into update()\n\n    moveTo(x, y) {\n        this.setTarget(x, y);\n    }\n\n    getColor() {\n        return PLAYER_COLORS[this.owner % PLAYER_COLORS.length];\n    }\n\n    die(type, node = null, game = null) {\n        this.dying = true;\n        this.deathType = type;\n        this.deathTime = 0;\n        this.absorbTarget = node;\n        const playerColor = this.getColor();\n        if (game && game.spawnParticles) {\n            if (type === 'explosion' || type === 'absorbed') {\n                game.spawnParticles(this.x, this.y, playerColor, 8, 'explosion');\n            } else if (type === 'attack') {\n                game.spawnParticles(this.x, this.y, playerColor, 5, 'hit');\n            }\n        }\n    }\n\n    isPointInside(mx, my, camera) {\n        const screen = camera.worldToScreen(this.x, this.y);\n        const dx = mx - screen.x;\n        const dy = my - screen.y;\n        return Math.sqrt(dx * dx + dy * dy) < (this.radius + 5) * camera.zoom;\n    }\n\n    isInsideRect(x1, y1, x2, y2, camera) {\n        const screen = camera.worldToScreen(this.x, this.y);\n        const minX = Math.min(x1, x2);\n        const maxX = Math.max(x1, x2);\n        const minY = Math.min(y1, y2);\n        const maxY = Math.max(y1, y2);\n        return screen.x >= minX && screen.x <= maxX && screen.y >= minY && screen.y <= maxY;\n    }\n}\n","export const PLAYER_COLORS = [\n    '#4CAF50', '#f44336', '#2196F3', '#FF9800',\n    '#9C27B0', '#00BCD4', '#FFEB3B', '#E91E63'\n];\n\nexport const GAME_SETTINGS = {\n    WORLD_WIDTH: 2400,\n    WORLD_HEIGHT: 1800,\n    WORLD_RADIUS: 1800, // Larger than map - units won't reach it often\n    OUTSIDE_DEATH_TIME: 5, // Seconds before unit dies outside boundary\n};\n\nexport const NODE_TYPES = {\n    small: { radius: 20, influenceFat: 4, baseHp: 4, maxHp: 12, stockFat: 0.5 },\n    medium: { radius: 32, influenceFat: 3.5, baseHp: 7, maxHp: 22, stockFat: 0.5 },\n    large: { radius: 55, influenceFat: 3, baseHp: 12, maxHp: 35, stockFat: 0.6 }\n};\n","import { GlobalSpawnTimer } from './GlobalSpawnTimer.js';\nimport { GAME_SETTINGS } from './GameConfig.js';\nimport { SpatialGrid } from './SpatialGrid.js';\n\nexport class GameState {\n    constructor() {\n        this.nodes = [];\n        this.entities = [];\n        this.playerCount = 1;\n        this.globalSpawnTimer = new GlobalSpawnTimer(2.5);\n        this.worldWidth = GAME_SETTINGS.WORLD_WIDTH;\n        this.worldHeight = GAME_SETTINGS.WORLD_HEIGHT;\n        this.elapsedTime = 0; // Track game time for escalation\n\n        // Game settings (from lobby)\n        this.speedMultiplier = 1;\n        this.accelerationEnabled = true;\n        this.showProduction = true;\n\n        // optimizations\n        this.spatialGrid = new SpatialGrid(this.worldWidth, this.worldHeight, 80); // 80px cells for units\n        this.spatialGridNodes = new SpatialGrid(this.worldWidth, this.worldHeight, 200); // 200px cells for nodes (larger radius)\n        this.maxEntitiesPerPlayer = 1000; // Increased to 1000 per user feedback\n        this.unitCounts = {}; // Cache unit counts per player for capping\n        this.flockUpdateCounter = 0; // Throttling for flock detection\n\n        // Statistics tracking\n        this.stats = {\n            startTime: Date.now(),\n            unitsProduced: {}, // playerId -> count\n            unitsLost: {}, // playerId -> count\n            unitsCurrent: {}, // playerId -> current count\n            capturedNodes: {}, // playerId -> count\n            history: [], // { time, playerId, count }\n            productionHistory: [] // { time, playerId, rate, total }\n        };\n    }\n\n    update(dt, gameInstance) {\n        this.elapsedTime += dt;\n        this.globalSpawnTimer.update(dt);\n\n        // Apply time-based escalation to spawn intervals\n        const timeBonus = Math.min(this.elapsedTime / 120, 1.0); // Max bonus at 2 minutes\n\n        // Populate spatial grid for nodes once (nodes don't move)\n        this.spatialGridNodes.clear();\n        this.nodes.forEach(node => {\n            this.spatialGridNodes.addObject(node);\n        });\n\n        // Populate spatial grid once per frame\n        this.spatialGrid.clear();\n        this.entities.forEach(ent => {\n            this.spatialGrid.addObject(ent);\n        });\n\n        // --- OPTIMIZACIN CPU: THROTTLING DE FLOCKS ---\n        // Detectar grupos (flocks) es costoso y no necesita ser frame-perfect.\n        // Lo corremos 1 vez cada 15 frames (~4 veces por segundo).\n        this.flockUpdateCounter++;\n        if (this.flockUpdateCounter >= 15) {\n            this._detectFlocks();\n            this.flockUpdateCounter = 0;\n        }\n\n        // Count units and production rates per player\n        this.unitCounts = {};\n        this.productionRates = {};\n        this.entities.forEach(ent => {\n            if (!ent.dead) {\n                this.unitCounts[ent.owner] = (this.unitCounts[ent.owner] || 0) + 1;\n            }\n        });\n\n        this.nodes.forEach(node => {\n            // Check cap before spawning\n            const canSpawn = (this.unitCounts[node.owner] || 0) < this.maxEntitiesPerPlayer;\n\n            const newEntity = node.update(dt, this.spatialGrid, this.globalSpawnTimer, gameInstance, this.nodes, canSpawn);\n            if (newEntity) {\n                this.entities.push(newEntity);\n                // Track production\n                const pid = newEntity.owner;\n                this.stats.unitsProduced[pid] = (this.stats.unitsProduced[pid] || 0) + 1;\n                this.unitCounts[pid] = (this.unitCounts[pid] || 0) + 1;\n\n                // Add new entity to grid immediately so it interacts\n                this.spatialGrid.addObject(newEntity);\n            }\n\n            // Track captures\n            if (node.justCapturedBy !== undefined) {\n                const pid = node.justCapturedBy;\n                this.stats.capturedNodes[pid] = (this.stats.capturedNodes[pid] || 0) + 1;\n                node.justCapturedBy = undefined;\n            }\n\n            // Aggregate production rates\n            if (node.owner !== -1) {\n                this.productionRates[node.owner] = (this.productionRates[node.owner] || 0) + (node.currentProductionRate || 0);\n            }\n        });\n\n        const currentUnits = {};\n        this.entities.forEach(ent => {\n            if (!ent.dead && !ent.dying) {\n                currentUnits[ent.owner] = (currentUnits[ent.owner] || 0) + 1;\n            }\n        });\n\n        // Track unit losses\n        this.entities.forEach(ent => {\n            if (ent.dead && !ent.lossTracked) {\n                ent.lossTracked = true;\n                const pid = ent.owner;\n                this.stats.unitsLost[pid] = (this.stats.unitsLost[pid] || 0) + 1;\n            }\n        });\n\n        // Update current counts\n        this.stats.unitsCurrent = currentUnits;\n\n        // Record history every second\n        const now = Date.now();\n        if (now - (this.stats.lastRecord || 0) > 1000) {\n            this.stats.lastRecord = now;\n\n            // Count current nodes owned\n            const nodesOwned = {};\n            this.nodes.forEach(n => {\n                if (n.owner !== -1) {\n                    nodesOwned[n.owner] = (nodesOwned[n.owner] || 0) + 1;\n                }\n            });\n\n            const elapsed = (now - this.stats.startTime) / 1000;\n\n            for (let pid in currentUnits) {\n                this.stats.history.push({\n                    time: elapsed,\n                    playerId: parseInt(pid),\n                    count: currentUnits[pid]\n                });\n            }\n\n            // Record node history\n            for (let pid in nodesOwned) {\n                if (!this.stats.nodeHistory) this.stats.nodeHistory = [];\n                this.stats.nodeHistory.push({\n                    time: elapsed,\n                    playerId: parseInt(pid),\n                    count: nodesOwned[pid]\n                });\n            }\n        }\n\n        // Record production rate every 5 seconds (more granular for graph)\n        if (now - (this.stats.lastProductionRecord || 0) > 5000) {\n            this.stats.lastProductionRecord = now;\n            const elapsed = (now - this.stats.startTime) / 60000;\n            for (let pid in this.stats.unitsProduced) {\n                // Use current production rate from nodes logic (units/sec -> units/min)\n                const currentRate = this.productionRates[pid] || 0;\n                const ratePerMin = Math.round(currentRate * 60);\n\n                this.stats.productionHistory.push({\n                    time: elapsed,\n                    playerId: parseInt(pid),\n                    rate: ratePerMin,\n                    total: this.stats.unitsProduced[pid] || 0\n                });\n            }\n        }\n\n        this.entities.forEach(ent => {\n            ent.update(dt, this.spatialGrid, this.spatialGridNodes, this.nodes, null, gameInstance);\n        });\n\n        // Clean up dead entities\n        this.entities = this.entities.filter(ent => !ent.dead);\n    }\n\n    getStats() {\n        const elapsed = (Date.now() - this.stats.startTime) / 60000; // minutes\n        const result = {\n            elapsed: elapsed,\n            produced: {},\n            lost: {},\n            current: {},\n            captured: {},\n            history: this.stats.history,\n            nodeHistory: this.stats.nodeHistory || [],\n            productionHistory: this.stats.productionHistory\n        };\n\n        for (let pid in this.stats.unitsProduced) {\n            result.produced[pid] = {\n                total: this.stats.unitsProduced[pid],\n                perMinute: elapsed > 0 ? Math.round(this.stats.unitsProduced[pid] / elapsed) : 0\n            };\n        }\n\n        for (let pid in this.stats.unitsLost) {\n            result.lost[pid] = {\n                total: this.stats.unitsLost[pid],\n                perMinute: elapsed > 0 ? Math.round(this.stats.unitsLost[pid] / elapsed) : 0\n            };\n        }\n\n        for (let pid in this.stats.unitsCurrent) {\n            result.current[pid] = this.stats.unitsCurrent[pid];\n        }\n\n        for (let pid in this.stats.capturedNodes) {\n            result.captured[pid] = this.stats.capturedNodes[pid];\n        }\n\n        return result;\n    }\n\n    getState() {\n        return {\n            nodes: this.nodes.map(n => ({\n                id: n.id, x: n.x, y: n.y, owner: n.owner, type: n.type,\n                radius: n.radius, influenceRadius: n.influenceRadius,\n                baseHp: n.baseHp, maxHp: n.maxHp, stock: n.stock,\n                maxStock: n.maxStock, spawnProgress: n.spawnProgress || 0,\n                rallyPoint: n.rallyPoint,\n                hitFlash: n.hitFlash || 0,\n                spawnEffect: n.spawnEffect || 0,\n                enemyPressure: n.enemyPressure || false\n            })),\n            entities: this.entities.map(e => ({\n                id: e.id, x: e.x, y: e.y, owner: e.owner, radius: e.radius,\n                vx: e.vx, vy: e.vy,\n                dying: e.dying, deathType: e.deathType, deathTime: e.deathTime,\n                outsideWarning: e.outsideWarning || false\n            })),\n            playerCount: this.playerCount,\n            elapsedTime: this.elapsedTime,\n            speedMultiplier: this.speedMultiplier,\n            accelerationEnabled: this.accelerationEnabled,\n            showProduction: this.showProduction,\n            stats: this.getStats(),\n            productionRates: this.productionRates\n        };\n    }\n\n    /**\n     * Detect flocks - for medium groups to create intimidating balls\n     */\n    _detectFlocks() {\n        const FLOCK_RADIUS = 45; // Medium radius for ball formation\n        const MIN_FLOCK_SIZE = 12; // Minimum units\n        const MAX_FLOCK_SIZE = 25; // Max units per flock - creates big intimidating balls\n\n        // Reset flock assignments\n        for (const ent of this.entities) {\n            if (!ent.dead && !ent.dying) {\n                ent.flockId = null;\n                ent.isFlockLeader = false;\n            }\n        }\n\n        // Group entities by owner and mark unassigned units\n        const byOwner = {};\n        for (const ent of this.entities) {\n            if (ent.dead || ent.dying) continue;\n            if (!byOwner[ent.owner]) byOwner[ent.owner] = [];\n            byOwner[ent.owner].push(ent);\n        }\n\n        // For each owner, find flocks using spatial grid\n        for (const ownerId in byOwner) {\n            const ownerEnts = byOwner[ownerId];\n            let flockCounter = 0;\n\n            for (const ent of ownerEnts) {\n                // Skip if already assigned to a flock\n                if (ent.flockId) continue;\n\n                // Find all units in this potential flock using spatial grid\n                const nearby = this.spatialGrid.retrieve(ent.x, ent.y, FLOCK_RADIUS);\n                const flock = [];\n\n                for (const other of nearby) {\n                    if (other.owner !== parseInt(ownerId)) continue;\n                    if (other.flockId) continue;\n                    if (other.dead || other.dying) continue;\n\n                    // Check actual distance\n                    const dx = other.x - ent.x;\n                    const dy = other.y - ent.y;\n                    if (dx * dx + dy * dy <= FLOCK_RADIUS * FLOCK_RADIUS) {\n                        flock.push(other);\n                        if (flock.length >= MAX_FLOCK_SIZE) break;\n                    }\n                }\n\n                // If we have enough units, assign flock ID\n                if (flock.length >= MIN_FLOCK_SIZE) {\n                    const flockId = `flock_${ownerId}_${flockCounter++}`;\n                    for (let i = 0; i < flock.length; i++) {\n                        flock[i].flockId = flockId;\n                        flock[i].isFlockLeader = (i === 0);\n                    }\n                }\n            }\n        }\n    }\n}\n","export class GlobalSpawnTimer {\n    constructor(interval = 2.5) {\n        this.interval = interval;\n        this.timer = 0;\n        this.shouldSpawn = false;\n    }\n    update(dt) {\n        this.timer += dt;\n        if (this.timer >= this.interval) {\n            this.timer = 0;\n            this.shouldSpawn = true;\n            return true;\n        }\n        this.shouldSpawn = false;\n        return false;\n    }\n}\n","import { Node } from './Node.js';\n\nexport class MapGenerator {\n    static generate(playerCount, worldWidth, worldHeight) {\n        const nodes = [];\n        let idCounter = 0;\n\n        const centerX = worldWidth / 2;\n        const centerY = worldHeight / 2;\n\n        // 1. Symmetrical Starting Positions for up to 4 players\n        const margin = 250;\n        const playerPositions = [\n            { x: margin, y: margin }, // Player 0 (Top Left)\n            { x: worldWidth - margin, y: worldHeight - margin }, // Player 1 (Bottom Right)\n            { x: worldWidth - margin, y: margin }, // Player 2 (Top Right)\n            { x: margin, y: worldHeight - margin } // Player 3 (Bottom Left)\n        ];\n\n        for (let i = 0; i < playerCount; i++) {\n            const pos = playerPositions[i] || { \n                x: centerX + (Math.random() - 0.5) * 400, \n                y: centerY + (Math.random() - 0.5) * 400 \n            };\n            nodes.push(new Node(idCounter++, pos.x, pos.y, i, 'large'));\n        }\n\n        // 2. Central Conflict Node (Guaranteed large)\n        nodes.push(new Node(idCounter++, centerX, centerY, -1, 'large'));\n\n        // Collision helper (ensures nodes don't overlap or get too close)\n        const canPlace = (x, y, r, existing) => {\n            for (let n of existing) {\n                const dx = x - (n.x || 0), dy = y - (n.y || 0);\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                const minDistance = r + (n.radius || 0) + 140; // Increased padding for better distribution\n                if (dist < minDistance) return false;\n            }\n            return true;\n        };\n\n        // 3. Mirror-based Node Generation for fairness\n        // Each quadrant will contribute a proportional amount of nodes\n        // Range: 5 to 8 nodes per player total.\n        const totalNeutralsGoal = Math.floor(playerCount * (5 + Math.random() * 3));\n        // Divided by 4 quadrants (rounded up)\n        const nodesPerQuadrant = Math.max(1, Math.ceil(totalNeutralsGoal / 4));\n\n        const quadrantNodes = [];\n        const tempAll = [...nodes];\n\n        for (let i = 0; i < nodesPerQuadrant; i++) {\n            let placed = false;\n            const typeProb = Math.random();\n            const type = typeProb > 0.8 ? 'large' : typeProb > 0.4 ? 'medium' : 'small';\n            const radius = type === 'large' ? 60 : type === 'medium' ? 35 : 20;\n\n            for (let attempt = 0; attempt < 100; attempt++) {\n                // Random position in the Top-Left quadrant\n                const x = 150 + Math.random() * (centerX - 300);\n                const y = 150 + Math.random() * (centerY - 300);\n\n                if (canPlace(x, y, radius, tempAll)) {\n                    quadrantNodes.push({ x, y, type, radius });\n                    tempAll.push({ x, y, radius });\n                    placed = true;\n                    break;\n                }\n            }\n        }\n\n        // Mirror the quadrant nodes symmetrically\n        quadrantNodes.forEach(q => {\n            nodes.push(new Node(idCounter++, q.x, q.y, -1, q.type)); // Top-Left\n            nodes.push(new Node(idCounter++, worldWidth - q.x, q.y, -1, q.type)); // Top-Right\n            nodes.push(new Node(idCounter++, q.x, worldHeight - q.y, -1, q.type)); // Bottom-Left\n            nodes.push(new Node(idCounter++, worldWidth - q.x, worldHeight - q.y, -1, q.type)); // Bottom-Right\n        });\n\n        return nodes;\n    }\n}\n","import { PLAYER_COLORS } from './GameConfig.js';\nimport { Entity } from './Entity.js'; // Circular dependency if Entity imports Node? Node doesn't import Entity class, but uses it in JSDoc maybe.\n// Actually Node creates new Entity in update(). So it needs to import Entity.\n\nexport class Node {\n    constructor(id, x, y, ownerId, type = 'medium') {\n        this.id = id; this.x = x; this.y = y; this.owner = ownerId; this.type = type;\n\n        if (type === 'small') {\n            this.radius = 20 + Math.random() * 5;\n            this.influenceRadius = this.radius * 4;\n            this.maxHp = 40; // Was 50\n            this.spawnInterval = 4.5; // Was 4.0 - Slower\n        }\n        else if (type === 'large') {\n            this.radius = 55 + Math.random() * 15;\n            this.influenceRadius = this.radius * 3;\n            this.maxHp = 150; // Was 180\n            this.spawnInterval = 2.4; // Was 2.0 - Slower\n        }\n        else {\n            this.radius = 35 + Math.random() * 8;\n            this.influenceRadius = this.radius * 3.5;\n            this.maxHp = 80; // Was 100\n            this.spawnInterval = 3.5; // Was 3.0 - Slower\n        }\n\n        // Neutral nodes start at 10% health (same)\n        // Owned nodes (starter) start at 50% health (Was 33%) -> Stronger start\n        this.baseHp = (this.owner === -1) ? (this.maxHp * 0.1) : (this.maxHp * 0.50);\n        this.stock = 0;\n\n        this.spawnEffect = 0;\n        this.spawnTimer = 0;\n        this.spawnProgress = 0;\n        this.defendersInside = 0; this.defenderCounts = {}; this.hitFlash = 0; this.selected = false; this.hasSpawnedThisCycle = false; this.rallyPoint = null; this.enemyPressure = false;\n        this.areaDefenders = []; this.allAreaDefenders = [];\n    }\n\n    getColor() { return this.owner === -1 ? '#757575' : PLAYER_COLORS[this.owner % PLAYER_COLORS.length]; }\n\n    setRallyPoint(x, y, targetNode = null) {\n        this.rallyPoint = { x, y };\n        this.rallyTargetNode = targetNode;\n    }\n\n    calculateDefenders(spatialGrid) {\n        this.defendersInside = 0;\n        this.stockDefenders = 0;\n        this.defenderCounts = {};\n        this.defendingEntities = [];\n        this.allAreaDefenders = [];\n\n        // Use spatial grid to find nearby entities\n        // Influence radius is the max check distance\n        const nearbyEntities = spatialGrid.retrieve(this.x, this.y, this.influenceRadius);\n\n        for (let e of nearbyEntities) {\n            if (e.dead || e.dying) continue;\n\n            // Squared distance check is faster\n            const dx = e.x - this.x;\n            const dy = e.y - this.y;\n            const distSq = dx * dx + dy * dy;\n\n            // Area de influencia\n            const influenceRadSq = this.influenceRadius * this.influenceRadius;\n            if (distSq <= influenceRadSq) {\n                this.defenderCounts[e.owner] = (this.defenderCounts[e.owner] || 0) + 1;\n                this.allAreaDefenders.push(e);\n                if (e.owner === this.owner) {\n                    this.areaDefenders.push(e);\n                }\n            }\n\n            // Dentro del nodo para stock\n            // Approximate radius check to avoid sqrt if possible, or just do it\n            const stockRad = this.radius + e.radius + 5;\n            if (distSq <= stockRad * stockRad) {\n                if (e.owner === this.owner) {\n                    this.defendersInside++;\n                    this.stockDefenders++;\n                    this.defendingEntities.push(e);\n                }\n            }\n        }\n    }\n\n    getTotalHp() {\n        return Math.min(this.maxHp, this.baseHp);\n    }\n\n    receiveAttack(attackerId, damage, game) {\n        // Don't allow defeated players to capture nodes\n        if (game && game.playerSockets) {\n            const player = game.playerSockets[attackerId];\n            if (player && player.defeated) {\n                return false; // Can't capture nodes\n            }\n        }\n\n        this.hitFlash = 0.3;\n        const attackerColor = PLAYER_COLORS[attackerId % PLAYER_COLORS.length];\n        if (game) game.spawnParticles(this.x, this.y, attackerColor, 3, 'hit');\n\n        this.baseHp -= damage;\n        if (this.baseHp <= 0) {\n            this.owner = attackerId;\n            // Captured nodes start at 10% health\n            this.baseHp = this.maxHp * 0.1;\n            this.stock = 0;\n            this.hasSpawnedThisCycle = false;\n            this.rallyPoint = null;\n            this.justCapturedBy = attackerId; // Flag for GameState stats\n            if (game) game.spawnParticles(this.x, this.y, PLAYER_COLORS[attackerId % PLAYER_COLORS.length], 20, 'explosion');\n            return true;\n        }\n        return false;\n    }\n\n    update(dt, spatialGrid, globalSpawnTimer, game, allNodes, canSpawn = true) {\n        this.calculateDefenders(spatialGrid);\n        if (this.hitFlash > 0) this.hitFlash -= dt;\n        if (this.spawnEffect > 0) this.spawnEffect -= dt;\n\n        // Check if enemies outnumber us in area - pause spawning\n        this.enemyPressure = false;\n        if (this.owner !== -1 && this.areaDefenders) {\n            const myDefenders = this.areaDefenders.length;\n            let enemyInArea = 0;\n            for (let e of this.allAreaDefenders) {\n                if (e.owner !== this.owner) enemyInArea++;\n            }\n            // If enemies outnumber us, pause spawn\n            if (enemyInArea > myDefenders) {\n                this.enemyPressure = true;\n            }\n        }\n\n        if (this.owner !== -1) {\n            // Heal node slowly if not at max\n            const healRate = 0.5;\n            if (this.baseHp < this.maxHp) {\n                this.baseHp += healRate * dt;\n            }\n\n            // Check if node is full (100%+ health = bonus production)\n            const isFull = this.baseHp >= this.maxHp;\n\n            this.spawnTimer += dt;\n            const healthPercent = Math.min(this.baseHp / this.maxHp, 1.0);\n\n            // Base generation: 0.5 at 0% HP, up to 1.5 at 100% HP (3x faster)\n            let healthScaling = 0.5 + healthPercent * 1.0;\n\n            // Extra bonus at full health (0.5 extra = up to 2x total)\n            if (isFull) {\n                healthScaling += 0.5;\n            }\n\n            // Type bonus: large nodes produce more\n            if (this.type === 'large') {\n                healthScaling += 0.5; // Large nodes get +50% production (reduced from 100%)\n            }\n\n            // Cluster bonus: more defenders = more production\n            const defenderCount = this.areaDefenders ? this.areaDefenders.length : 0;\n            const clusterBonus = Math.min(defenderCount * 0.1, 0.5); // Up to 0.5 extra with 5+ defenders\n            healthScaling += clusterBonus;\n\n            const spawnThreshold = this.spawnInterval / healthScaling;\n\n            // Store current production rate for UI (units per second)\n            // If neutral, production is effectively 0 for player stats\n            this.currentProductionRate = (this.owner !== -1) ? (1 / spawnThreshold) : 0;\n            // Player must click to spawn units\n            if (!this.manualSpawnReady && this.spawnTimer >= spawnThreshold && this.baseHp > (this.maxHp * 0.1)) {\n                // Auto spawn is disabled - just reset timer and show progress\n                this.manualSpawnReady = true;\n            }\n\n            // Manual spawn - when player clicks on node\n            // Added check for canSpawn to implement entity cap\n            if (canSpawn && this.manualSpawnReady && this.spawnTimer >= spawnThreshold && this.baseHp > (this.maxHp * 0.1)) {\n                this.spawnTimer = 0;\n                this.manualSpawnReady = false;\n\n                // Spawn at middle of influence radius (not too close to edge, not too close to center)\n                const angle = Math.random() * Math.PI * 2;\n                const spawnDist = this.influenceRadius * 0.6; // 60% from center\n                const ex = this.x + Math.cos(angle) * spawnDist, ey = this.y + Math.sin(angle) * spawnDist;\n                const entity = new Entity(ex, ey, this.owner, Date.now() + Math.random());\n\n                // If no rally point, just stay there floating (no target)\n                if (!this.rallyPoint) {\n                    // No target - will float in place with random movement\n                } else {\n                    entity.setTarget(this.rallyPoint.x, this.rallyPoint.y, this.rallyTargetNode);\n                }\n\n                this.spawnEffect = 0.4;\n                if (game) game.spawnParticles(this.x, this.y, this.getColor(), 6, 'explosion');\n                return entity;\n            }\n\n            // Show progress\n            this.spawnProgress = this.spawnTimer / spawnThreshold;\n        } else {\n            this.spawnTimer = 0;\n            this.spawnProgress = 0;\n        }\n        return null;\n    }\n    isPointInside(mx, my, camera) {\n        const screen = camera.worldToScreen(this.x, this.y);\n        const dx = mx - screen.x;\n        const dy = my - screen.y;\n        return Math.sqrt(dx * dx + dy * dy) < (this.radius + 10) * camera.zoom;\n    }\n\n    isInsideRect(x1, y1, x2, y2, camera) {\n        const screen = camera.worldToScreen(this.x, this.y);\n        const minX = Math.min(x1, x2);\n        const maxX = Math.max(x1, x2);\n        const minY = Math.min(y1, y2);\n        const maxY = Math.max(y1, y2);\n        return screen.x >= minX && screen.x <= maxX && screen.y >= minY && screen.y <= maxY;\n    }\n}\n","export class SpatialGrid {\n    constructor(width, height, cellSize) {\n        this.width = width;\n        this.height = height;\n        this.cellSize = cellSize;\n        this.cols = Math.ceil(width / cellSize);\n        this.rows = Math.ceil(height / cellSize);\n        this.cells = new Map();\n        this.queryIds = 0;\n        \n        // Pre-allocated array for retrieve() to avoid GC\n        this._resultArray = [];\n        this._resultLength = 0;\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n\n    _getKey(col, row) {\n        return col + \",\" + row;\n    }\n\n    addObject(obj) {\n        const col = Math.floor(obj.x / this.cellSize);\n        const row = Math.floor(obj.y / this.cellSize);\n\n        if (col >= 0 && col < this.cols && row >= 0 && row < this.rows) {\n            const key = this._getKey(col, row);\n            if (!this.cells.has(key)) {\n                this.cells.set(key, []);\n            }\n            this.cells.get(key).push(obj);\n        }\n    }\n\n    // Retrieve objects - optimized with pre-allocated array\n    retrieve(x, y, radius) {\n        // Reset result array without allocation\n        this._resultLength = 0;\n        \n        const startCol = Math.floor((x - radius) / this.cellSize);\n        const endCol = Math.floor((x + radius) / this.cellSize);\n        const startRow = Math.floor((y - radius) / this.cellSize);\n        const endRow = Math.floor((y + radius) / this.cellSize);\n\n        for (let c = startCol; c <= endCol; c++) {\n            if (c < 0 || c >= this.cols) continue;\n            for (let r = startRow; r <= endRow; r++) {\n                if (r < 0 || r >= this.rows) continue;\n\n                const key = this._getKey(c, r);\n                const cellObjects = this.cells.get(key);\n                if (cellObjects) {\n                    for (let i = 0; i < cellObjects.length; i++) {\n                        this._resultArray[this._resultLength++] = cellObjects[i];\n                    }\n                }\n            }\n        }\n        return this._resultArray;\n    }\n\n    // Callback-based query - most efficient, no allocations\n    query(x, y, radius, callback) {\n        const startCol = Math.floor((x - radius) / this.cellSize);\n        const endCol = Math.floor((x + radius) / this.cellSize);\n        const startRow = Math.floor((y - radius) / this.cellSize);\n        const endRow = Math.floor((y + radius) / this.cellSize);\n\n        for (let c = startCol; c <= endCol; c++) {\n            if (c < 0 || c >= this.cols) continue;\n            for (let r = startRow; r <= endRow; r++) {\n                if (r < 0 || r >= this.rows) continue;\n\n                const key = this._getKey(c, r);\n                const cellObjects = this.cells.get(key);\n                if (cellObjects) {\n                    for (let i = 0; i < cellObjects.length; i++) {\n                        callback(cellObjects[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    // Retrieve only nodes - also optimized\n    retrieveNodes(x, y, searchRadius) {\n        this._resultLength = 0;\n        \n        const startCol = Math.floor((x - searchRadius) / this.cellSize);\n        const endCol = Math.floor((x + searchRadius) / this.cellSize);\n        const startRow = Math.floor((y - searchRadius) / this.cellSize);\n        const endRow = Math.floor((y + searchRadius) / this.cellSize);\n\n        for (let c = startCol; c <= endCol; c++) {\n            if (c < 0 || c >= this.cols) continue;\n            for (let r = startRow; r <= endRow; r++) {\n                if (r < 0 || r >= this.rows) continue;\n\n                const key = this._getKey(c, r);\n                const cellObjects = this.cells.get(key);\n                if (cellObjects) {\n                    for (let i = 0; i < cellObjects.length; i++) {\n                        const node = cellObjects[i];\n                        if (node && node.influenceRadius !== undefined) {\n                            this._resultArray[this._resultLength++] = node;\n                        }\n                    }\n                }\n            }\n        }\n        return this._resultArray;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Game } from './core/Game.js';\nimport { InputManager } from './systems/InputManager.js';\nimport { SelectionManager } from './systems/SelectionManager.js';\nimport { UIManager } from './systems/UIManager.js';\nimport { SingleplayerController } from './modes/SingleplayerController.js';\nimport { MultiplayerController } from './modes/MultiplayerController.js';\nimport { GameState } from '../shared/GameState.js';\nimport { sounds } from './systems/SoundManager.js';\n\nwindow.initGame = (mode) => {\n    const game = new Game('game-canvas');\n\n    // Initialize Systems\n    game.systems = {\n        selection: new SelectionManager(game),\n        ui: new UIManager(game)\n    };\n    game.systems.input = new InputManager(game);\n\n    // Initialize Mode\n    if (mode === 'singleplayer') {\n        const urlParams = new URLSearchParams(window.location.search);\n        const playerCount = parseInt(urlParams.get('players')) || 2;\n        const difficulty = urlParams.get('difficulty') || 'intermediate';\n        const testMode = urlParams.get('test') === '1';\n        \n        game.controller = new SingleplayerController(game);\n        game.controller.setup(playerCount, difficulty, testMode);\n        \n        // Show game UI and screen\n        const ui = document.getElementById('ui');\n        const menu = document.getElementById('menu-screen');\n        if (ui) ui.style.display = 'block';\n        if (menu) menu.style.display = 'none';\n        \n        game.resize();\n        game.start();\n    } else {\n        // Multiplayer - controller is set up when connecting\n        game.controller = new MultiplayerController(game);\n        game.controller.connect();\n    }\n\n    // Setup menu button\n    const menuBtn = document.getElementById('menu-btn');\n    if (menuBtn) {\n        menuBtn.addEventListener('click', () => {\n            game.running = false;\n            location.href = 'index.html';\n        });\n    }\n\n    // Setup mute button\n    const muteBtn = document.getElementById('mute-btn');\n    if (muteBtn) {\n        muteBtn.addEventListener('click', () => {\n            const enabled = sounds.toggle();\n            muteBtn.textContent = enabled ? '' : '';\n            muteBtn.style.background = enabled ? 'rgba(76,175,80,0.8)' : 'rgba(244,67,54,0.8)';\n            muteBtn.style.borderColor = enabled ? '#4CAF50' : '#f44336';\n        });\n    }\n\n    // Show surrender button only in multiplayer\n    if (mode === 'multiplayer') {\n        const surrenderBtn = document.getElementById('surrender-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        if (surrenderBtn) surrenderBtn.style.display = 'block';\n        if (resetBtn) resetBtn.style.display = 'none';\n    }\n\n    // Setup reset button for singleplayer\n    if (mode === 'singleplayer') {\n        const resetBtn = document.getElementById('reset-btn');\n        if (resetBtn) {\n            resetBtn.addEventListener('click', () => {\n                const urlParams = new URLSearchParams(window.location.search);\n                const playerCount = parseInt(urlParams.get('players')) || 2;\n                const difficulty = urlParams.get('difficulty') || 'intermediate';\n                const testMode = urlParams.get('test') === '1';\n                \n                // Stop current game properly\n                game.stop();\n                game.gameOverShown = false;\n                \n                // Clear state - create fresh GameState\n                game.state = new GameState();\n                game.state.playerCount = game.controller.ais.length + 1;\n                game.particles = [];\n                game.commandIndicators = [];\n                game.waypointLines = [];\n                game.systems.selection.clear();\n                \n                // Re-setup with new map\n                game.controller.setup(playerCount, difficulty, testMode);\n                game.start();\n            });\n        }\n    }\n\n    // Setup surrender button for multiplayer\n    if (mode === 'multiplayer') {\n        const surrenderBtn = document.getElementById('surrender-btn');\n        if (surrenderBtn) {\n            surrenderBtn.addEventListener('click', () => {\n                if (game.controller && game.controller.surrender) {\n                    game.controller.surrender();\n                }\n            });\n        }\n    }\n\n    return game;\n};\n\n// Auto-init based on page\ndocument.addEventListener('DOMContentLoaded', () => {\n    if (document.getElementById('game-canvas')) {\n        // Check if singleplayer by path or by URL params\n        const isSingle = window.location.pathname.includes('singleplayer') || \n                         new URLSearchParams(window.location.search).has('players');\n        window.initGame(isSingle ? 'singleplayer' : 'multiplayer');\n    }\n});\n"],"names":[],"sourceRoot":""}